{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"jitkasi","text":"<p>Like minkasi but with JAX. Don't use this, its mostly just for fun (for now)</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>noise</li> <li>tod</li> </ul>"},{"location":"reference/noise/","title":"noise","text":""},{"location":"reference/noise/#jitkasi.noise.NoiseSmoothedSVD","title":"<code>NoiseSmoothedSVD</code>  <code>dataclass</code>","text":"<p>The standard \"Jon style\" noise model. Here we use the SVD to compute the noise spectrum. This is assuming that we are operating on noise dominated data. This class is a registered pytree so it is JITable with JAX.</p> <p>While this model is applied in fourier space it appears to be mathematically the same as if we computed \\(N^{-1}\\) directly from the SVD and then dotted that into the data being filtered. Math showing this (if actually true) will exist in the docs one day...</p> <p>Attributes:</p> Name Type Description <code>v</code> <code>Array</code> <p>The right singular vectors to of the modeled noise. This is used to rotate any input data into the space of the noise. This is a child of the pytree.</p> <code>filt_spectrum</code> <code>Array</code> <p>The inverse of the smoothed sepctrum of the noise model. This is used as a filter to remove the modeled noise in fourier space.</p> Source code in <code>jitkasi/noise.py</code> <pre><code>@register_pytree_node_class\n@dataclass\nclass NoiseSmoothedSVD:\n    \"\"\"\n    The standard \"Jon style\" noise model.\n    Here we use the SVD to compute the noise spectrum.\n    This is assuming that we are operating on noise dominated data.\n    This class is a registered pytree so it is JITable with JAX.\n\n    While this model is applied in fourier space it appears to be mathematically\n    the same as if we computed $N^{-1}$ directly from the SVD and then dotted that\n    into the data being filtered. Math showing this (if actually true) will exist\n    in the docs one day...\n\n    Attributes\n    ----------\n    v : Array\n        The right singular vectors to of the modeled noise.\n        This is used to rotate any input data into the space of the noise.\n        This is a child of the pytree.\n    filt_spectrum : Array\n        The inverse of the smoothed sepctrum of the noise model.\n        This is used as a filter to remove the modeled noise in fourier space.\n    \"\"\"\n\n    v: Array\n    filt_spectrum: Array\n\n    @jit\n    def apply_noise(self, dat: Array) -&gt; Array:\n        \"\"\"\n        Apply the noise model.\n        The procedure here is to rotate the data into the space of the noise,\n        then filter out the noise in fourier space, and then rotate back.\n\n        Parameters\n        ----------\n        dat : Array\n            The data to apply the noise model to.\n            Should be 2d with `dat.shape[0] == len(self.weights)`.\n\n        Returns\n        -------\n        dat_filt : Array\n            The data with the noise model applied.\n        \"\"\"\n        dat_rot = jnp.dot(self.v, dat)\n        dat_tmp = jnp.hstack([dat_rot, jnp.fliplr(dat_rot[:, 1:-1])])\n        dat_rft = jnp.real(jnp.fft.rfft(dat_tmp, axis=1))\n        dat_filt = jnp.fft.irfft(\n            self.filt_spectrum[:, : dat_rft.shape[1]] * dat_rft, axis=1, norm=\"forward\"\n        )[:, : dat.shape[1]]\n        dat_filt = jnp.dot(self.v.T, dat_filt)\n        dat_filt = dat_filt.at[:, 0].multiply(0.50)\n        dat_filt = dat_filt.at[:, -1].multiply(0.50)\n        return dat_filt\n\n    @classmethod\n    @partial(jit, static_argnums=(0,))\n    def compute(cls, dat: Array, fwhm: float) -&gt; Self:\n        \"\"\"\n        Compute this noise model based on some input data.\n        To do this we compute the SVD of the data, rotate into its sigular space,\n        and then compute the spectrum of each rotated detector.\n        These spectra are then smoothed and a filter a made by squaring and\n        inverting the smoothed filter.\n\n        Parameters\n        ----------\n        dat : Array\n            The data to estimate the white noise levels from.\n            Should be a 2d array.\n\n        Returns\n        -------\n        noise_model : NoiseWhite\n            An instance of NoiseWhite with the computed noise model.\n        \"\"\"\n        u, *_ = jnp.linalg.svd(dat, True)\n        v = u.T\n        dat_rot = jnp.dot(v, dat)\n        dat_ft = jnp.real(jnp.fft.rfft(dat_rot))\n        smooth_kern = jnp.exp(\n            -0.5 * (jnp.arange(dat_ft.shape[1]) * jnp.sqrt(8 * jnp.log(2)) / fwhm) ** 2\n        )\n        for i in range(dat_ft.shape[0]):\n            dat_ft = dat_ft.at[i].set(jnp.convolve(dat_ft[i], smooth_kern) ** 2)\n        dat_ft = dat_ft.at[:, 1:].set(1.0 / dat_ft[:, 1:])\n        dat_ft = dat_ft.at[:, 0].set(0)\n        return cls(v, dat_ft)\n\n    # Functions for making this a pytree\n    # Don't call this on your own\n    def tree_flatten(self) -&gt; tuple[tuple, None]:\n        children = (self.v, self.filt_spectrum)\n        aux_data = None\n\n        return (children, aux_data)\n\n    @classmethod\n    def tree_unflatten(cls, aux_data, children) -&gt; Self:\n        return cls(*children)\n</code></pre>"},{"location":"reference/noise/#jitkasi.noise.NoiseSmoothedSVD.apply_noise","title":"<code>apply_noise(dat)</code>","text":"<p>Apply the noise model. The procedure here is to rotate the data into the space of the noise, then filter out the noise in fourier space, and then rotate back.</p> <p>Parameters:</p> Name Type Description Default <code>dat</code> <code>Array</code> <p>The data to apply the noise model to. Should be 2d with <code>dat.shape[0] == len(self.weights)</code>.</p> required <p>Returns:</p> Name Type Description <code>dat_filt</code> <code>Array</code> <p>The data with the noise model applied.</p> Source code in <code>jitkasi/noise.py</code> <pre><code>@jit\ndef apply_noise(self, dat: Array) -&gt; Array:\n    \"\"\"\n    Apply the noise model.\n    The procedure here is to rotate the data into the space of the noise,\n    then filter out the noise in fourier space, and then rotate back.\n\n    Parameters\n    ----------\n    dat : Array\n        The data to apply the noise model to.\n        Should be 2d with `dat.shape[0] == len(self.weights)`.\n\n    Returns\n    -------\n    dat_filt : Array\n        The data with the noise model applied.\n    \"\"\"\n    dat_rot = jnp.dot(self.v, dat)\n    dat_tmp = jnp.hstack([dat_rot, jnp.fliplr(dat_rot[:, 1:-1])])\n    dat_rft = jnp.real(jnp.fft.rfft(dat_tmp, axis=1))\n    dat_filt = jnp.fft.irfft(\n        self.filt_spectrum[:, : dat_rft.shape[1]] * dat_rft, axis=1, norm=\"forward\"\n    )[:, : dat.shape[1]]\n    dat_filt = jnp.dot(self.v.T, dat_filt)\n    dat_filt = dat_filt.at[:, 0].multiply(0.50)\n    dat_filt = dat_filt.at[:, -1].multiply(0.50)\n    return dat_filt\n</code></pre>"},{"location":"reference/noise/#jitkasi.noise.NoiseSmoothedSVD.compute","title":"<code>compute(dat, fwhm)</code>  <code>classmethod</code>","text":"<p>Compute this noise model based on some input data. To do this we compute the SVD of the data, rotate into its sigular space, and then compute the spectrum of each rotated detector. These spectra are then smoothed and a filter a made by squaring and inverting the smoothed filter.</p> <p>Parameters:</p> Name Type Description Default <code>dat</code> <code>Array</code> <p>The data to estimate the white noise levels from. Should be a 2d array.</p> required <p>Returns:</p> Name Type Description <code>noise_model</code> <code>NoiseWhite</code> <p>An instance of NoiseWhite with the computed noise model.</p> Source code in <code>jitkasi/noise.py</code> <pre><code>@classmethod\n@partial(jit, static_argnums=(0,))\ndef compute(cls, dat: Array, fwhm: float) -&gt; Self:\n    \"\"\"\n    Compute this noise model based on some input data.\n    To do this we compute the SVD of the data, rotate into its sigular space,\n    and then compute the spectrum of each rotated detector.\n    These spectra are then smoothed and a filter a made by squaring and\n    inverting the smoothed filter.\n\n    Parameters\n    ----------\n    dat : Array\n        The data to estimate the white noise levels from.\n        Should be a 2d array.\n\n    Returns\n    -------\n    noise_model : NoiseWhite\n        An instance of NoiseWhite with the computed noise model.\n    \"\"\"\n    u, *_ = jnp.linalg.svd(dat, True)\n    v = u.T\n    dat_rot = jnp.dot(v, dat)\n    dat_ft = jnp.real(jnp.fft.rfft(dat_rot))\n    smooth_kern = jnp.exp(\n        -0.5 * (jnp.arange(dat_ft.shape[1]) * jnp.sqrt(8 * jnp.log(2)) / fwhm) ** 2\n    )\n    for i in range(dat_ft.shape[0]):\n        dat_ft = dat_ft.at[i].set(jnp.convolve(dat_ft[i], smooth_kern) ** 2)\n    dat_ft = dat_ft.at[:, 1:].set(1.0 / dat_ft[:, 1:])\n    dat_ft = dat_ft.at[:, 0].set(0)\n    return cls(v, dat_ft)\n</code></pre>"},{"location":"reference/noise/#jitkasi.noise.NoiseWhite","title":"<code>NoiseWhite</code>  <code>dataclass</code>","text":"<p>A simple noise model with only white noise. This is equivalent to a diagonal \\(N^{-1}\\). This class is a registered pytree so it is JITable with JAX.</p> <p>Attributes:</p> Name Type Description <code>weights</code> <code>Array</code> <p>The per-detector weights conputed from the white noise. This is a child of the pytree.</p> Source code in <code>jitkasi/noise.py</code> <pre><code>@register_pytree_node_class\n@dataclass\nclass NoiseWhite:\n    \"\"\"\n    A simple noise model with only white noise.\n    This is equivalent to a diagonal $N^{-1}$.\n    This class is a registered pytree so it is JITable with JAX.\n\n    Attributes\n    ----------\n    weights: Array\n        The per-detector weights conputed from the white noise.\n        This is a child of the pytree.\n    \"\"\"\n\n    weights: Array\n\n    @jit\n    def apply_noise(self, dat: Array) -&gt; Array:\n        \"\"\"\n        Apply the noise model.\n        In this case this is just rescaling each detector by its weight.\n\n        Parameters\n        ----------\n        dat : Array\n            The data to apply the noise model to.\n            Should be 2d with `dat.shape[0] == len(self.weights)`.\n\n        Returns\n        -------\n        dat_filt : Array\n            The data with the noise model applied.\n        \"\"\"\n        return dat * self.weights[..., None]\n\n    @classmethod\n    @partial(jit, static_argnums=(0,))\n    def compute(cls, dat: Array) -&gt; Self:\n        \"\"\"\n        Compute this noise model based on some input data.\n        Here we just estimate the variance of each detector in dat.\n\n        Parameters\n        ----------\n        dat : Array\n            The data to estimate the white noise levels from.\n            Should be a 2d array.\n\n        Returns\n        -------\n        noise_model : NoiseWhite\n            An instance of NoiseWhite with the computed noise model.\n        \"\"\"\n        weights = (\n            2 * erfinv(0.5) / jnp.median(jnp.abs(jnp.diff(dat, axis=1)), axis=1)\n        ) ** 2\n        return cls(weights)\n\n    # Functions for making this a pytree\n    # Don't call this on your own\n    def tree_flatten(self) -&gt; tuple[tuple, None]:\n        children = (self.weights,)\n        aux_data = None\n\n        return (children, aux_data)\n\n    @classmethod\n    def tree_unflatten(cls, aux_data, children) -&gt; Self:\n        return cls(*children)\n</code></pre>"},{"location":"reference/noise/#jitkasi.noise.NoiseWhite.apply_noise","title":"<code>apply_noise(dat)</code>","text":"<p>Apply the noise model. In this case this is just rescaling each detector by its weight.</p> <p>Parameters:</p> Name Type Description Default <code>dat</code> <code>Array</code> <p>The data to apply the noise model to. Should be 2d with <code>dat.shape[0] == len(self.weights)</code>.</p> required <p>Returns:</p> Name Type Description <code>dat_filt</code> <code>Array</code> <p>The data with the noise model applied.</p> Source code in <code>jitkasi/noise.py</code> <pre><code>@jit\ndef apply_noise(self, dat: Array) -&gt; Array:\n    \"\"\"\n    Apply the noise model.\n    In this case this is just rescaling each detector by its weight.\n\n    Parameters\n    ----------\n    dat : Array\n        The data to apply the noise model to.\n        Should be 2d with `dat.shape[0] == len(self.weights)`.\n\n    Returns\n    -------\n    dat_filt : Array\n        The data with the noise model applied.\n    \"\"\"\n    return dat * self.weights[..., None]\n</code></pre>"},{"location":"reference/noise/#jitkasi.noise.NoiseWhite.compute","title":"<code>compute(dat)</code>  <code>classmethod</code>","text":"<p>Compute this noise model based on some input data. Here we just estimate the variance of each detector in dat.</p> <p>Parameters:</p> Name Type Description Default <code>dat</code> <code>Array</code> <p>The data to estimate the white noise levels from. Should be a 2d array.</p> required <p>Returns:</p> Name Type Description <code>noise_model</code> <code>NoiseWhite</code> <p>An instance of NoiseWhite with the computed noise model.</p> Source code in <code>jitkasi/noise.py</code> <pre><code>@classmethod\n@partial(jit, static_argnums=(0,))\ndef compute(cls, dat: Array) -&gt; Self:\n    \"\"\"\n    Compute this noise model based on some input data.\n    Here we just estimate the variance of each detector in dat.\n\n    Parameters\n    ----------\n    dat : Array\n        The data to estimate the white noise levels from.\n        Should be a 2d array.\n\n    Returns\n    -------\n    noise_model : NoiseWhite\n        An instance of NoiseWhite with the computed noise model.\n    \"\"\"\n    weights = (\n        2 * erfinv(0.5) / jnp.median(jnp.abs(jnp.diff(dat, axis=1)), axis=1)\n    ) ** 2\n    return cls(weights)\n</code></pre>"},{"location":"reference/tod/","title":"tod","text":""},{"location":"reference/tod/#jitkasi.tod.TOD","title":"<code>TOD</code>  <code>dataclass</code>","text":"<p>Class for storing time ordered data. This class is a registered pytree so it is JITable with JAX.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>Array</code> <p>The detector data for this TOD. This is a child of the pytree.</p> <code>x</code> <code>Array</code> <p>The x sky coordinates for this TOD. Nominally this should be RA in radians. Note that eventually this may become a cached property to enable on the fly pointing reconstruction for large expiriments. This is a child of the pytree.</p> <code>y</code> <code>Array</code> <p>The y sky coordinates for this TOD. Nominally this should be Dec in radians. Note that eventually this may become a cached property to enable on the fly pointing reconstruction for large expiriments. This is a child of the pytree.</p> <code>noise</code> <code>Optional[NoiseModel]</code> <p>The noise model for this TOD. Should be None when no model is initialized. This is aux data for the pytree.</p> <code>meta</code> <code>dict</code> <p>Additional metadata associated with the TOD. This is supplied only for user convenience and should not be relied on in any <code>jitkasi</code> library code. It is intended to be used in user made scripts only. This is aux data for the pytree</p> Source code in <code>jitkasi/tod.py</code> <pre><code>@register_pytree_node_class\n@dataclass\nclass TOD:\n    \"\"\"\n    Class for storing time ordered data.\n    This class is a registered pytree so it is JITable with JAX.\n\n    Attributes\n    ----------\n    data : Array\n        The detector data for this TOD.\n        This is a child of the pytree.\n    x : Array\n        The x sky coordinates for this TOD.\n        Nominally this should be RA in radians.\n        Note that eventually this may become a cached property\n        to enable on the fly pointing reconstruction for large expiriments.\n        This is a child of the pytree.\n    y : Array\n        The y sky coordinates for this TOD.\n        Nominally this should be Dec in radians.\n        Note that eventually this may become a cached property\n        to enable on the fly pointing reconstruction for large expiriments.\n        This is a child of the pytree.\n    noise : Optional[NoiseModel]\n        The noise model for this TOD.\n        Should be None when no model is initialized.\n        This is aux data for the pytree.\n    meta : dict\n        Additional metadata associated with the TOD.\n        This is supplied **only** for user convenience and\n        should **not** be relied on in any `jitkasi` library code.\n        It is intended to be used in user made scripts only.\n        This is aux data for the pytree\n    \"\"\"\n\n    data: Array\n    x: Array\n    y: Array\n    noise: Optional[n.NoiseModel] = None\n    meta: dict = {}\n\n    def __post_init__(self):\n        # Check that all sizes are the same\n        shapes = [self.data.shape, self.x.shape, self.y.shape]\n        if not (\n            all(s[0] == shapes[0][0] for s in shapes)\n            and all(s[1] == shapes[0][1] for s in shapes)\n        ):\n            raise ValueError(\n                f\"Expected 'data', 'x', and 'y' to have the same shape but got {shapes}.\"\n            )\n\n    @property\n    def shape(self) -&gt; tuple[int, ...]:\n        \"\"\"\n        Get the shape of the TOD's data.\n\n        Returns\n        -------\n        shape : tupe[int, ....]\n            The shape of the TOD.\n        \"\"\"\n        return self.data.shape\n\n    @property\n    def lims(self) -&gt; tuple[float, float, float, float]:\n        \"\"\"\n        Get the limits of the TODs coordinates.\n\n        Returns\n        -------\n        x0 : float\n            The minimum x value.\n        x1 : float\n            The maximum x value.\n        y0 : float\n            The minimum y value.\n        y1 : float\n            The maximum y value.\n        \"\"\"\n        return (\n            float(jnp.min(self.x)),\n            float(jnp.max(self.x)),\n            float(jnp.min(self.y)),\n            float(jnp.max(self.y)),\n        )\n\n    @cached_property\n    def data_filt(self) -&gt; Array:\n        \"\"\"\n        Get a copy of the data with the noise model applied.\n        This is essentially $N^{-1}d$\n\n        Returns\n        -------\n        data_filt : Array\n            The filtered data.\n            If `self.noise` is None then this is just a copy of `self.data`.\n        \"\"\"\n        if self.noise is None:\n            return jnp.copy(self.data)\n        return self.noise.apply_noise(self.data)\n\n    def copy(self, deep: bool = False) -&gt; Self:\n        \"\"\"\n        Return of copy of the TOD.\n\n        Parameters\n        ----------\n        deep : bool, default: False\n            If True do a deepcopy so that all contained\n            data is also copied. Otherwise a shallow copy is\n            made and the new TOD will reference the same arrays.\n\n        Returns\n        -------\n        copy : TOD\n            A copy of this TOD.\n        \"\"\"\n        if deep:\n            return deepcopy(self)\n        return copy(self)\n\n    def compute_noise(self, noise_class: n.NoiseModel, *args, **kwargs):\n        \"\"\"\n        Compute and set the noise model for this TOD.\n        This uses `noise_class.compute(dat=self.data...` to compute the noise.\n        Also resets the cache on `data_filt`.\n\n        Parameters\n        ----------\n        noise_class : NoiseModel\n            The class to use as the noise model.\n            Nominally a class from `jitkasi.noise`.\n        *args\n            Additional arguments to pass to `noise_class.compute`.\n        *kwargs\n            Additional keyword arguments to pass to `noise_class.compute`.\n        \"\"\"\n        self.__dict__.pop(\"data_filt\", None)\n        self.noise = noise_class.compute(self.data, *args, **kwargs)\n\n    # Functions for making this a pytree\n    # Don't call this on your own\n    def tree_flatten(self) -&gt; tuple[tuple, tuple]:\n        children = (self.data, self.x, self.y)\n        aux_data = (self.noise, self.meta)\n\n        return (children, aux_data)\n\n    @classmethod\n    def tree_unflatten(cls, aux_data, children) -&gt; Self:\n        return cls(*children, *aux_data)\n</code></pre>"},{"location":"reference/tod/#jitkasi.tod.TOD.data_filt","title":"<code>data_filt: Array</code>  <code>cached</code> <code>property</code>","text":"<p>Get a copy of the data with the noise model applied. This is essentially \\(N^{-1}d\\)</p> <p>Returns:</p> Name Type Description <code>data_filt</code> <code>Array</code> <p>The filtered data. If <code>self.noise</code> is None then this is just a copy of <code>self.data</code>.</p>"},{"location":"reference/tod/#jitkasi.tod.TOD.lims","title":"<code>lims: tuple[float, float, float, float]</code>  <code>property</code>","text":"<p>Get the limits of the TODs coordinates.</p> <p>Returns:</p> Name Type Description <code>x0</code> <code>float</code> <p>The minimum x value.</p> <code>x1</code> <code>float</code> <p>The maximum x value.</p> <code>y0</code> <code>float</code> <p>The minimum y value.</p> <code>y1</code> <code>float</code> <p>The maximum y value.</p>"},{"location":"reference/tod/#jitkasi.tod.TOD.shape","title":"<code>shape: tuple[int, ...]</code>  <code>property</code>","text":"<p>Get the shape of the TOD's data.</p> <p>Returns:</p> Name Type Description <code>shape</code> <code>tupe[int, ....]</code> <p>The shape of the TOD.</p>"},{"location":"reference/tod/#jitkasi.tod.TOD.compute_noise","title":"<code>compute_noise(noise_class, *args, **kwargs)</code>","text":"<p>Compute and set the noise model for this TOD. This uses <code>noise_class.compute(dat=self.data...</code> to compute the noise. Also resets the cache on <code>data_filt</code>.</p> <p>Parameters:</p> Name Type Description Default <code>noise_class</code> <code>NoiseModel</code> <p>The class to use as the noise model. Nominally a class from <code>jitkasi.noise</code>.</p> required <code>*args</code> <p>Additional arguments to pass to <code>noise_class.compute</code>.</p> <code>()</code> <code>*kwargs</code> <p>Additional keyword arguments to pass to <code>noise_class.compute</code>.</p> <code>{}</code> Source code in <code>jitkasi/tod.py</code> <pre><code>def compute_noise(self, noise_class: n.NoiseModel, *args, **kwargs):\n    \"\"\"\n    Compute and set the noise model for this TOD.\n    This uses `noise_class.compute(dat=self.data...` to compute the noise.\n    Also resets the cache on `data_filt`.\n\n    Parameters\n    ----------\n    noise_class : NoiseModel\n        The class to use as the noise model.\n        Nominally a class from `jitkasi.noise`.\n    *args\n        Additional arguments to pass to `noise_class.compute`.\n    *kwargs\n        Additional keyword arguments to pass to `noise_class.compute`.\n    \"\"\"\n    self.__dict__.pop(\"data_filt\", None)\n    self.noise = noise_class.compute(self.data, *args, **kwargs)\n</code></pre>"},{"location":"reference/tod/#jitkasi.tod.TOD.copy","title":"<code>copy(deep=False)</code>","text":"<p>Return of copy of the TOD.</p> <p>Parameters:</p> Name Type Description Default <code>deep</code> <code>bool</code> <p>If True do a deepcopy so that all contained data is also copied. Otherwise a shallow copy is made and the new TOD will reference the same arrays.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>copy</code> <code>TOD</code> <p>A copy of this TOD.</p> Source code in <code>jitkasi/tod.py</code> <pre><code>def copy(self, deep: bool = False) -&gt; Self:\n    \"\"\"\n    Return of copy of the TOD.\n\n    Parameters\n    ----------\n    deep : bool, default: False\n        If True do a deepcopy so that all contained\n        data is also copied. Otherwise a shallow copy is\n        made and the new TOD will reference the same arrays.\n\n    Returns\n    -------\n    copy : TOD\n        A copy of this TOD.\n    \"\"\"\n    if deep:\n        return deepcopy(self)\n    return copy(self)\n</code></pre>"},{"location":"reference/tod/#jitkasi.tod.TODVec","title":"<code>TODVec</code>  <code>dataclass</code>","text":"<p>Class to store collections of TODs. Eventually this will be responsible for handling most collective (and MPI aware) operations on TODs.</p> <p>Attributes:</p> Name Type Description <code>tods</code> <code>list[TOD]</code> <p>The TODs that belong to this TODVec. This is accessible via  <code>__getitem__</code> and <code>__setitem__</code>.</p> Source code in <code>jitkasi/tod.py</code> <pre><code>@dataclass\nclass TODVec:\n    \"\"\"\n    Class to store collections of TODs.\n    Eventually this will be responsible for handling most\n    collective (and MPI aware) operations on TODs.\n\n    Attributes\n    ----------\n    tods : list[TOD]\n        The TODs that belong to this TODVec.\n        This is accessible via  `__getitem__` and `__setitem__`.\n    \"\"\"\n\n    tods: list[TOD] = []\n\n    @property\n    def lims(self) -&gt; tuple[float, float, float, float]:\n        \"\"\"\n        Get the global limits of all the TODs coordinates.\n        Will eventually be MPI aware.\n\n        Returns\n        -------\n        x0 : float\n            The minimum x value.\n        x1 : float\n            The maximum x value.\n        y0 : float\n            The minimum y value.\n        y1 : float\n            The maximum y value.\n        \"\"\"\n        all_lims = [tod.lims for tod in self.tods]\n        all_lims = jnp.array(all_lims).reshape(-1, 4)\n        lims = jnp.max(all_lims, axis=0)\n        return tuple(lims)[:4]\n\n    def copy(self, deep: bool = False) -&gt; Self:\n        \"\"\"\n        Return of copy of the TODVec.\n\n        Parameters\n        ----------\n        deep : bool, default: False\n            If True do a deepcopy so that all contained\n            TODs are also copied. Otherwise a shallow copy is\n            made and the new TODVec will reference the same TODs.\n\n        Returns\n        -------\n        copy : TODVec\n            A copy of this TODVec.\n        \"\"\"\n        if deep:\n            return deepcopy(self)\n        return copy(self)\n\n    # Functions to make this list like\n    def __getitem__(self, key: int) -&gt; TOD:\n        if not isinstance(key, int):\n            raise TypeError(\"TODVec is indexed by ints\")\n        return self.tods[key]\n\n    def __setitem__(self, key: int, value: TOD):\n        if not isinstance(key, int):\n            raise TypeError(\"TODVec is indexed by ints\")\n        if not isinstance(value, TOD):\n            raise TypeError(\"TODVec can only store instances of TOD\")\n\n        self.tods[key] = value\n\n    def __delitem__(self, key: int):\n        if not isinstance(key, int):\n            raise TypeError(\"TODVec is indexed by ints\")\n        del self.tods[key]\n\n    def __iter__(self) -&gt; Iterable[TOD]:\n        return self.tods.__iter__()\n\n    def __add__(self, other: Self) -&gt; Self:\n        if not isinstance(other, TODVec):\n            raise TypeError(\"Can only add other TODVecs to a TODVec\")\n        new = self.copy()\n        new += other\n        return new\n\n    def __radd__(self, other: Self) -&gt; Self:\n        if not isinstance(other, TODVec):\n            raise TypeError(\"Can only add other TODVecs to a TODVec\")\n        new = other.copy()\n        new += self\n        return new\n\n    def __iadd__(self, other: Self):\n        if not isinstance(other, TODVec):\n            raise TypeError(\"Can only add other TODVecs to a TODVec\")\n        self.tods += other.tods\n        return self\n\n    def insert(self, key: int, value: TOD):\n        if not isinstance(key, int):\n            raise TypeError(\"TODVec is indexed by ints\")\n        if not isinstance(value, TOD):\n            raise TypeError(\"TODVec can only store instances of TOD\")\n\n        self.tods.insert(key, value)\n\n    def append(self, value):\n        if not isinstance(value, TOD):\n            raise TypeError(\"TODVec can only store instances of TOD\")\n\n        self.tods.append(value)\n</code></pre>"},{"location":"reference/tod/#jitkasi.tod.TODVec.lims","title":"<code>lims: tuple[float, float, float, float]</code>  <code>property</code>","text":"<p>Get the global limits of all the TODs coordinates. Will eventually be MPI aware.</p> <p>Returns:</p> Name Type Description <code>x0</code> <code>float</code> <p>The minimum x value.</p> <code>x1</code> <code>float</code> <p>The maximum x value.</p> <code>y0</code> <code>float</code> <p>The minimum y value.</p> <code>y1</code> <code>float</code> <p>The maximum y value.</p>"},{"location":"reference/tod/#jitkasi.tod.TODVec.copy","title":"<code>copy(deep=False)</code>","text":"<p>Return of copy of the TODVec.</p> <p>Parameters:</p> Name Type Description Default <code>deep</code> <code>bool</code> <p>If True do a deepcopy so that all contained TODs are also copied. Otherwise a shallow copy is made and the new TODVec will reference the same TODs.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>copy</code> <code>TODVec</code> <p>A copy of this TODVec.</p> Source code in <code>jitkasi/tod.py</code> <pre><code>def copy(self, deep: bool = False) -&gt; Self:\n    \"\"\"\n    Return of copy of the TODVec.\n\n    Parameters\n    ----------\n    deep : bool, default: False\n        If True do a deepcopy so that all contained\n        TODs are also copied. Otherwise a shallow copy is\n        made and the new TODVec will reference the same TODs.\n\n    Returns\n    -------\n    copy : TODVec\n        A copy of this TODVec.\n    \"\"\"\n    if deep:\n        return deepcopy(self)\n    return copy(self)\n</code></pre>"}]}