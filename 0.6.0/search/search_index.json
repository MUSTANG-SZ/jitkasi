{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"jitkasi","text":"<p>Like minkasi but with JAX. Don't use this, its mostly just for fun (for now)</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>mapmaking</li> <li>noise</li> <li>solutions</li> <li>tod</li> </ul>"},{"location":"reference/mapmaking/","title":"mapmaking","text":"<p>Core mapmaking functions</p>"},{"location":"reference/mapmaking/#jitkasi.mapmaking.make_lhs","title":"<code>make_lhs(solutionset, todvec)</code>","text":"<p>Make the left hand side of the map maker equation: \\(P^{T}N^{-1}Pm\\). To do this we project the Solutions into TODs, apply the noise model, and project back to Solutions.</p> <p>Parameters:</p> Name Type Description Default <code>solutionset</code> <code>SolutionSet</code> <p>SolutionSet containing the things you are trying to solve for. This is not modified in place.</p> required <code>todvec</code> <code>TODVec</code> <p>TODVec containing TODs to project into and from. Only used for pointing and shape information, not modified in place.</p> required <p>Returns:</p> Name Type Description <code>lhs</code> <code>SolutionSet</code> <p>A SolutionSet for the left hand side of the map maker equation.</p> Source code in <code>jitkasi/mapmaking.py</code> <pre><code>@jit\ndef make_lhs(solutionset: SolutionSet, todvec: TODVec) -&gt; SolutionSet:\n    \"\"\"\n    Make the left hand side of the map maker equation: $P^{T}N^{-1}Pm$.\n    To do this we project the Solutions into TODs, apply the noise model,\n    and project back to Solutions.\n\n    Parameters\n    ----------\n    solutionset : SolutionSet\n        SolutionSet containing the things you are trying to solve for.\n        This is not modified in place.\n    todvec : TODVec\n        TODVec containing TODs to project into and from.\n        Only used for pointing and shape information,\n        not modified in place.\n\n    Returns\n    -------\n    lhs : SolutionSet\n        A SolutionSet for the left hand side of the map maker equation.\n    \"\"\"\n    projected = solutionset.to_tods(todvec)\n    lhs = solutionset.from_tods(projected, True)\n    return lhs\n</code></pre>"},{"location":"reference/mapmaking/#jitkasi.mapmaking.make_rhs","title":"<code>make_rhs(solutionset, todvec)</code>","text":"<p>Make the right hand side of the map maker equation: \\(P^{T}N^{-1}d\\). To do this we apply the noise model to some TODs and project into Solutions.</p> <p>Parameters:</p> Name Type Description Default <code>solutionset</code> <code>SolutionSet</code> <p>SolutionSet containing the things you are trying to solve for. This is not modified in place.</p> required <code>todvec</code> <code>TODVec</code> <p>TODVec containing TODs to project from. This is not modified in place.</p> required <p>Returns:</p> Name Type Description <code>rhs</code> <code>SolutionSet</code> <p>A SolutionSet for the right hand side of the map maker equation.</p> Source code in <code>jitkasi/mapmaking.py</code> <pre><code>@jit\ndef make_rhs(solutionset: SolutionSet, todvec: TODVec) -&gt; SolutionSet:\n    \"\"\"\n    Make the right hand side of the map maker equation: $P^{T}N^{-1}d$.\n    To do this we apply the noise model to some TODs and project into Solutions.\n\n    Parameters\n    ----------\n    solutionset : SolutionSet\n        SolutionSet containing the things you are trying to solve for.\n        This is not modified in place.\n    todvec : TODVec\n        TODVec containing TODs to project from.\n        This is not modified in place.\n\n    Returns\n    -------\n    rhs : SolutionSet\n        A SolutionSet for the right hand side of the map maker equation.\n    \"\"\"\n    rhs = solutionset.from_tods(todvec, True)\n    return rhs\n</code></pre>"},{"location":"reference/mapmaking/#jitkasi.mapmaking.run_pcg","title":"<code>run_pcg(rhs, todvec, x0, precon, maxiter=100)</code>","text":"<p>Solve using Preconditioned Conjugate Gradient (PCG). This iteratively approximates the solution to \\(Ax = b\\), where \\(A\\) is a matrix and \\(x\\) and \\(b\\) are vectors.</p> <p>In ML mapmaking we are solving \\(P^{T}N^{-1}Pm = P^{T}N^{-1}d\\) so \\(m\\) is \\(x\\) in the general linear equation and is what we are solving for (usually a map, but perhaps some simultanious terms such as cuts).</p> <p>Parameters:</p> Name Type Description Default <code>rhs</code> <code>SolutionSet</code> <p>The right hand side of the mapmaker equation: \\(P^{T}N{-1}d\\). This is \\(b\\) in the general linear equation.</p> required <code>todvec</code> <code>TODvec</code> <p>TODVec containing the TODs we are solving with. This is \\(d\\) in the mapmaker equation.</p> required <code>x0</code> <code>SolutionSet</code> <p>Initial guess for the solution.</p> required <code>precon</code> <code>SolutionsSet</code> <p>Preconditioner to apply at easy iteration. This makes things more invertible.</p> required <code>maxiter</code> <code>int</code> <p>The number of PCG iters to run</p> <code>100</code> <p>Returns:</p> Name Type Description <code>x</code> <code>SolutionSet</code> <p>The solved SolutionSet. This is \\(m\\) in the mapmaker equation.</p> Source code in <code>jitkasi/mapmaking.py</code> <pre><code>@jit\ndef run_pcg(\n    rhs: SolutionSet,\n    todvec: TODVec,\n    x0: SolutionSet,\n    precon: SolutionSet,\n    maxiter: int = 100,\n) -&gt; SolutionSet:\n    \"\"\"\n    Solve using Preconditioned Conjugate Gradient (PCG).\n    This iteratively approximates the solution to $Ax = b$,\n    where $A$ is a matrix and $x$ and $b$ are vectors.\n\n    In ML mapmaking we are solving $P^{T}N^{-1}Pm = P^{T}N^{-1}d$\n    so $m$ is $x$ in the general linear equation and is what we are solving for\n    (usually a map, but perhaps some simultanious terms such as cuts).\n\n    Parameters\n    ----------\n    rhs : SolutionSet\n        The right hand side of the mapmaker equation: $P^{T}N{-1}d$.\n        This is $b$ in the general linear equation.\n    todvec : TODvec\n        TODVec containing the TODs we are solving with.\n        This is $d$ in the mapmaker equation.\n    x0 : SolutionSet\n        Initial guess for the solution.\n    precon : SolutionsSet\n        Preconditioner to apply at easy iteration.\n        This makes things more invertible.\n    maxiter : int, default: 100\n        The number of PCG iters to run\n\n\n    Returns\n    -------\n    x : SolutionSet\n        The solved SolutionSet.\n        This is $m$ in the mapmaker equation.\n    \"\"\"\n    lhs = make_lhs(x0, todvec)\n\n    # compute the remainder r_0\n    r = rhs - lhs\n    z = precon * r\n\n    # Initial p_0 = z_0 = M*r_0\n    p = z.copy(deep=True)\n\n    # compute z*r, which is used for computing alpha\n    zr = r @ z\n    # make a copy of our initial guess\n    x = x0.copy(deep=True)\n    alpha = 0\n    for _ in range(maxiter):\n        # Compute pAp\n        Ap = make_lhs(p, todvec)\n        pAp = p @ Ap\n\n        # Compute alpha_k\n        alpha = zr / pAp\n\n        # Update guess using alpha\n        x = p - alpha * x\n\n        # Write down next remainder r_k+1\n        r = Ap - alpha * r\n\n        # Apply preconditioner\n        z = precon * r\n\n        # compute new z_k+1\n        zr_old = zr\n        zr = r @ z\n\n        # compute beta_k, which is used to compute p_k+1\n        beta = zr / zr_old\n\n        # compute new p_k+1\n        p = p + beta * p\n\n    return x\n</code></pre>"},{"location":"reference/noise/","title":"noise","text":""},{"location":"reference/noise/#jitkasi.noise.NoiseSmoothedSVD","title":"<code>NoiseSmoothedSVD</code>  <code>dataclass</code>","text":"<p>The standard \"Jon style\" noise model. Here we use the SVD to compute the noise spectrum. This is assuming that we are operating on noise dominated data. This class is a registered pytree so it is JITable with JAX.</p> <p>While this model is applied in fourier space it appears to be mathematically the same as if we computed \\(N^{-1}\\) directly from the SVD and then dotted that into the data being filtered. Math showing this (if actually true) will exist in the docs one day...</p> <p>Attributes:</p> Name Type Description <code>v</code> <code>Array</code> <p>The right singular vectors to of the modeled noise. This is used to rotate any input data into the space of the noise. This is a child of the pytree.</p> <code>filt_spectrum</code> <code>Array</code> <p>The inverse of the smoothed sepctrum of the noise model. This is used as a filter to remove the modeled noise in fourier space.</p> Source code in <code>jitkasi/noise.py</code> <pre><code>@register_pytree_node_class\n@dataclass\nclass NoiseSmoothedSVD:\n    \"\"\"\n    The standard \"Jon style\" noise model.\n    Here we use the SVD to compute the noise spectrum.\n    This is assuming that we are operating on noise dominated data.\n    This class is a registered pytree so it is JITable with JAX.\n\n    While this model is applied in fourier space it appears to be mathematically\n    the same as if we computed $N^{-1}$ directly from the SVD and then dotted that\n    into the data being filtered. Math showing this (if actually true) will exist\n    in the docs one day...\n\n    Attributes\n    ----------\n    v : Array\n        The right singular vectors to of the modeled noise.\n        This is used to rotate any input data into the space of the noise.\n        This is a child of the pytree.\n    filt_spectrum : Array\n        The inverse of the smoothed sepctrum of the noise model.\n        This is used as a filter to remove the modeled noise in fourier space.\n    \"\"\"\n\n    v: Array\n    filt_spectrum: Array\n\n    @jit\n    def apply_noise(self, dat: Array) -&gt; Array:\n        \"\"\"\n        Apply the noise model.\n        The procedure here is to rotate the data into the space of the noise,\n        then filter out the noise in fourier space, and then rotate back.\n\n        Parameters\n        ----------\n        dat : Array\n            The data to apply the noise model to.\n            Should be 2d with `dat.shape[0] == len(self.weights)`.\n\n        Returns\n        -------\n        dat_filt : Array\n            The data with the noise model applied.\n        \"\"\"\n        dat_rot = jnp.dot(self.v, dat)\n        dat_tmp = jnp.hstack([dat_rot, jnp.fliplr(dat_rot[:, 1:-1])])\n        dat_rft = jnp.real(jnp.fft.rfft(dat_tmp, axis=1))\n        dat_filt = jnp.fft.irfft(\n            self.filt_spectrum[:, : dat_rft.shape[1]] * dat_rft, axis=1, norm=\"forward\"\n        )[:, : dat.shape[1]]\n        dat_filt = jnp.dot(self.v.T, dat_filt)\n        dat_filt = dat_filt.at[:, 0].multiply(0.50)\n        dat_filt = dat_filt.at[:, -1].multiply(0.50)\n        return dat_filt\n\n    @classmethod\n    @partial(jit, static_argnums=(0,))\n    def compute(cls, dat: Array, fwhm: float) -&gt; Self:\n        \"\"\"\n        Compute this noise model based on some input data.\n        To do this we compute the SVD of the data, rotate into its sigular space,\n        and then compute the spectrum of each rotated detector.\n        These spectra are then smoothed and a filter a made by squaring and\n        inverting the smoothed filter.\n\n        Parameters\n        ----------\n        dat : Array\n            The data to estimate the white noise levels from.\n            Should be a 2d array.\n\n        Returns\n        -------\n        noise_model : NoiseWhite\n            An instance of NoiseWhite with the computed noise model.\n        \"\"\"\n        u, *_ = jnp.linalg.svd(dat, True)\n        v = u.T\n        dat_rot = jnp.dot(v, dat)\n        dat_ft = jnp.real(jnp.fft.rfft(dat_rot))\n        smooth_kern = jnp.exp(\n            -0.5 * (jnp.arange(dat_ft.shape[1]) * jnp.sqrt(8 * jnp.log(2)) / fwhm) ** 2\n        )\n        for i in range(dat_ft.shape[0]):\n            dat_ft = dat_ft.at[i].set(jnp.convolve(dat_ft[i], smooth_kern) ** 2)\n        dat_ft = dat_ft.at[:, 1:].set(1.0 / dat_ft[:, 1:])\n        dat_ft = dat_ft.at[:, 0].set(0)\n        return cls(v, dat_ft)\n\n    # Functions for making this a pytree\n    # Don't call this on your own\n    def tree_flatten(self) -&gt; tuple[tuple, None]:\n        children = (self.v, self.filt_spectrum)\n        aux_data = None\n\n        return (children, aux_data)\n\n    @classmethod\n    def tree_unflatten(cls, aux_data, children) -&gt; Self:\n        return cls(*children)\n</code></pre>"},{"location":"reference/noise/#jitkasi.noise.NoiseSmoothedSVD.apply_noise","title":"<code>apply_noise(dat)</code>","text":"<p>Apply the noise model. The procedure here is to rotate the data into the space of the noise, then filter out the noise in fourier space, and then rotate back.</p> <p>Parameters:</p> Name Type Description Default <code>dat</code> <code>Array</code> <p>The data to apply the noise model to. Should be 2d with <code>dat.shape[0] == len(self.weights)</code>.</p> required <p>Returns:</p> Name Type Description <code>dat_filt</code> <code>Array</code> <p>The data with the noise model applied.</p> Source code in <code>jitkasi/noise.py</code> <pre><code>@jit\ndef apply_noise(self, dat: Array) -&gt; Array:\n    \"\"\"\n    Apply the noise model.\n    The procedure here is to rotate the data into the space of the noise,\n    then filter out the noise in fourier space, and then rotate back.\n\n    Parameters\n    ----------\n    dat : Array\n        The data to apply the noise model to.\n        Should be 2d with `dat.shape[0] == len(self.weights)`.\n\n    Returns\n    -------\n    dat_filt : Array\n        The data with the noise model applied.\n    \"\"\"\n    dat_rot = jnp.dot(self.v, dat)\n    dat_tmp = jnp.hstack([dat_rot, jnp.fliplr(dat_rot[:, 1:-1])])\n    dat_rft = jnp.real(jnp.fft.rfft(dat_tmp, axis=1))\n    dat_filt = jnp.fft.irfft(\n        self.filt_spectrum[:, : dat_rft.shape[1]] * dat_rft, axis=1, norm=\"forward\"\n    )[:, : dat.shape[1]]\n    dat_filt = jnp.dot(self.v.T, dat_filt)\n    dat_filt = dat_filt.at[:, 0].multiply(0.50)\n    dat_filt = dat_filt.at[:, -1].multiply(0.50)\n    return dat_filt\n</code></pre>"},{"location":"reference/noise/#jitkasi.noise.NoiseSmoothedSVD.compute","title":"<code>compute(dat, fwhm)</code>  <code>classmethod</code>","text":"<p>Compute this noise model based on some input data. To do this we compute the SVD of the data, rotate into its sigular space, and then compute the spectrum of each rotated detector. These spectra are then smoothed and a filter a made by squaring and inverting the smoothed filter.</p> <p>Parameters:</p> Name Type Description Default <code>dat</code> <code>Array</code> <p>The data to estimate the white noise levels from. Should be a 2d array.</p> required <p>Returns:</p> Name Type Description <code>noise_model</code> <code>NoiseWhite</code> <p>An instance of NoiseWhite with the computed noise model.</p> Source code in <code>jitkasi/noise.py</code> <pre><code>@classmethod\n@partial(jit, static_argnums=(0,))\ndef compute(cls, dat: Array, fwhm: float) -&gt; Self:\n    \"\"\"\n    Compute this noise model based on some input data.\n    To do this we compute the SVD of the data, rotate into its sigular space,\n    and then compute the spectrum of each rotated detector.\n    These spectra are then smoothed and a filter a made by squaring and\n    inverting the smoothed filter.\n\n    Parameters\n    ----------\n    dat : Array\n        The data to estimate the white noise levels from.\n        Should be a 2d array.\n\n    Returns\n    -------\n    noise_model : NoiseWhite\n        An instance of NoiseWhite with the computed noise model.\n    \"\"\"\n    u, *_ = jnp.linalg.svd(dat, True)\n    v = u.T\n    dat_rot = jnp.dot(v, dat)\n    dat_ft = jnp.real(jnp.fft.rfft(dat_rot))\n    smooth_kern = jnp.exp(\n        -0.5 * (jnp.arange(dat_ft.shape[1]) * jnp.sqrt(8 * jnp.log(2)) / fwhm) ** 2\n    )\n    for i in range(dat_ft.shape[0]):\n        dat_ft = dat_ft.at[i].set(jnp.convolve(dat_ft[i], smooth_kern) ** 2)\n    dat_ft = dat_ft.at[:, 1:].set(1.0 / dat_ft[:, 1:])\n    dat_ft = dat_ft.at[:, 0].set(0)\n    return cls(v, dat_ft)\n</code></pre>"},{"location":"reference/noise/#jitkasi.noise.NoiseWhite","title":"<code>NoiseWhite</code>  <code>dataclass</code>","text":"<p>A simple noise model with only white noise. This is equivalent to a diagonal \\(N^{-1}\\). This class is a registered pytree so it is JITable with JAX.</p> <p>Attributes:</p> Name Type Description <code>weights</code> <code>Array</code> <p>The per-detector weights conputed from the white noise. This is a child of the pytree.</p> Source code in <code>jitkasi/noise.py</code> <pre><code>@register_pytree_node_class\n@dataclass\nclass NoiseWhite:\n    \"\"\"\n    A simple noise model with only white noise.\n    This is equivalent to a diagonal $N^{-1}$.\n    This class is a registered pytree so it is JITable with JAX.\n\n    Attributes\n    ----------\n    weights: Array\n        The per-detector weights conputed from the white noise.\n        This is a child of the pytree.\n    \"\"\"\n\n    weights: Array\n\n    @jit\n    def apply_noise(self, dat: Array) -&gt; Array:\n        \"\"\"\n        Apply the noise model.\n        In this case this is just rescaling each detector by its weight.\n\n        Parameters\n        ----------\n        dat : Array\n            The data to apply the noise model to.\n            Should be 2d with `dat.shape[0] == len(self.weights)`.\n\n        Returns\n        -------\n        dat_filt : Array\n            The data with the noise model applied.\n        \"\"\"\n        return dat * self.weights[..., None]\n\n    @classmethod\n    @partial(jit, static_argnums=(0,))\n    def compute(cls, dat: Array) -&gt; Self:\n        \"\"\"\n        Compute this noise model based on some input data.\n        Here we just estimate the variance of each detector in dat.\n\n        Parameters\n        ----------\n        dat : Array\n            The data to estimate the white noise levels from.\n            Should be a 2d array.\n\n        Returns\n        -------\n        noise_model : NoiseWhite\n            An instance of NoiseWhite with the computed noise model.\n        \"\"\"\n        weights = (\n            2 * erfinv(0.5) / jnp.median(jnp.abs(jnp.diff(dat, axis=1)), axis=1)\n        ) ** 2\n        return cls(weights)\n\n    # Functions for making this a pytree\n    # Don't call this on your own\n    def tree_flatten(self) -&gt; tuple[tuple, None]:\n        children = (self.weights,)\n        aux_data = None\n\n        return (children, aux_data)\n\n    @classmethod\n    def tree_unflatten(cls, aux_data, children) -&gt; Self:\n        return cls(*children)\n</code></pre>"},{"location":"reference/noise/#jitkasi.noise.NoiseWhite.apply_noise","title":"<code>apply_noise(dat)</code>","text":"<p>Apply the noise model. In this case this is just rescaling each detector by its weight.</p> <p>Parameters:</p> Name Type Description Default <code>dat</code> <code>Array</code> <p>The data to apply the noise model to. Should be 2d with <code>dat.shape[0] == len(self.weights)</code>.</p> required <p>Returns:</p> Name Type Description <code>dat_filt</code> <code>Array</code> <p>The data with the noise model applied.</p> Source code in <code>jitkasi/noise.py</code> <pre><code>@jit\ndef apply_noise(self, dat: Array) -&gt; Array:\n    \"\"\"\n    Apply the noise model.\n    In this case this is just rescaling each detector by its weight.\n\n    Parameters\n    ----------\n    dat : Array\n        The data to apply the noise model to.\n        Should be 2d with `dat.shape[0] == len(self.weights)`.\n\n    Returns\n    -------\n    dat_filt : Array\n        The data with the noise model applied.\n    \"\"\"\n    return dat * self.weights[..., None]\n</code></pre>"},{"location":"reference/noise/#jitkasi.noise.NoiseWhite.compute","title":"<code>compute(dat)</code>  <code>classmethod</code>","text":"<p>Compute this noise model based on some input data. Here we just estimate the variance of each detector in dat.</p> <p>Parameters:</p> Name Type Description Default <code>dat</code> <code>Array</code> <p>The data to estimate the white noise levels from. Should be a 2d array.</p> required <p>Returns:</p> Name Type Description <code>noise_model</code> <code>NoiseWhite</code> <p>An instance of NoiseWhite with the computed noise model.</p> Source code in <code>jitkasi/noise.py</code> <pre><code>@classmethod\n@partial(jit, static_argnums=(0,))\ndef compute(cls, dat: Array) -&gt; Self:\n    \"\"\"\n    Compute this noise model based on some input data.\n    Here we just estimate the variance of each detector in dat.\n\n    Parameters\n    ----------\n    dat : Array\n        The data to estimate the white noise levels from.\n        Should be a 2d array.\n\n    Returns\n    -------\n    noise_model : NoiseWhite\n        An instance of NoiseWhite with the computed noise model.\n    \"\"\"\n    weights = (\n        2 * erfinv(0.5) / jnp.median(jnp.abs(jnp.diff(dat, axis=1)), axis=1)\n    ) ** 2\n    return cls(weights)\n</code></pre>"},{"location":"reference/solutions/","title":"solutions","text":""},{"location":"reference/solutions/#jitkasi.solutions.Solution","title":"<code>Solution</code>  <code>dataclass</code>","text":"<p>Base class defining required functionality for a solution. For mapmaking all that we really need is code to project to and from TODs, additional helper functions are probably needed but anything that needs to be included in a mapmaking script explicitly should be clearly documented.</p> <p>This class is non functional but all actual solutions (maps, cuts, etc.) should subclass it and ensure that the required functions are implemented.</p> <p>Attributes:</p> Name Type Description <code>params</code> <code>Array</code> <p>The model params we are solving for. For example if we are solving for a map then this is the map, if we are solving for cuts then this is the modeled offsets. Mathematically this is \\(m\\) in \\(d = Pm + n\\). This should always be a child of the pytree.</p> Source code in <code>jitkasi/solutions.py</code> <pre><code>@register_pytree_node_class\n@dataclass\nclass Solution:\n    \"\"\"\n    Base class defining required functionality for a solution.\n    For mapmaking all that we really need is code to project to and from TODs,\n    additional helper functions are probably needed but anything that needs to\n    be included in a mapmaking script explicitly should be clearly documented.\n\n    This class is non functional but all actual solutions (maps, cuts, etc.) should\n    subclass it and ensure that the required functions are implemented.\n\n    Attributes\n    ----------\n    params : Array\n        The model params we are solving for.\n        For example if we are solving for a map then this is the map,\n        if we are solving for cuts then this is the modeled offsets.\n        Mathematically this is $m$ in $d = Pm + n$.\n        This should always be a child of the pytree.\n    \"\"\"\n\n    params: Array\n\n    @jit\n    def to_tods(self, todvec: TODVec) -&gt; TODVec:  # type: ignore\n        pass\n\n    @jit\n    def from_tods(self, todvec: TODVec, use_filt: bool = True) -&gt; Self:  # type: ignore\n        pass\n\n    @classmethod\n    def empty(cls, **kwargs) -&gt; Self:  # type: ignore\n        pass\n\n    def copy(self, deep: bool = False) -&gt; Self:\n        \"\"\"\n        Return of copy of the Solution.\n\n        Parameters\n        ----------\n        deep : bool, default: False\n            If True do a deepcopy so that all contained\n            data is also copied. Otherwise a mostly shallow copy is\n            made and the new Solution will reference the same objects\n            except for `params` which will be a copy.\n\n        Returns\n        -------\n        copy : Solution\n            A copy of this Solution.\n        \"\"\"\n        if deep:\n            return deepcopy(self)\n        else:\n            new = copy(self)\n            new.params = new.params.copy()\n            return new\n\n    # Math functions\n    def _self_check(self, other: Self):\n        pass\n\n    def _get_to_op(self, other: Any) -&gt; Array | float:\n        if isinstance(other, type(self)):\n            to_op = other.params\n            self._self_check(other)\n        elif isinstance(other, (float, int)):\n            to_op = float(other)\n        else:\n            raise TypeError(f\"Cannot use type {type(other)} to operate on {type(self)}\")\n        return to_op\n\n    def __iadd__(self, other: Self | float) -&gt; Self:\n        to_add = self._get_to_op(other)\n        self.params = _iadd(self.params, to_add)\n        return self\n\n    def __add__(self, other: Self | float) -&gt; Self:\n        to_ret = self.copy()\n        to_ret += other\n        return to_ret\n\n    def __radd__(self, other: Self | float) -&gt; Self:\n        return self.__add__(other)\n\n    def __isub__(self, other: Any) -&gt; Self:\n        to_sub = self._get_to_op(other)\n        self.params = _isub(self.params, to_sub)\n        return self\n\n    def __sub__(self, other: Any) -&gt; Self:\n        to_ret = self.copy()\n        to_ret -= other\n        return to_ret\n\n    def __rsub__(self, other: Any) -&gt; Self:\n        return self.__sub__(other)\n\n    def __imul__(self, other: Any) -&gt; Self:\n        to_sub = self._get_to_op(other)\n        self.params = _imul(self.params, to_sub)\n        return self\n\n    def __mul__(self, other: Any) -&gt; Self:\n        to_ret = self.copy()\n        to_ret *= other\n        return to_ret\n\n    def __rmul__(self, other: Any) -&gt; Self:\n        return self.__mul__(other)\n\n    @jit\n    def __matmul__(self, other: Self) -&gt; float:\n        if not isinstance(other, type(self)):\n            raise ValueError(f\"Can't dot {type(other)} and {type(self)}\")\n        return float(jnp.sum(self.params * other.params, axis=None))\n\n    # Functions for making this a pytree\n    # Don't call this on your own\n    def tree_flatten(self) -&gt; tuple[tuple, Optional[tuple]]:\n        children = (self.params,)\n        aux_data = None\n\n        return (children, aux_data)\n\n    @classmethod\n    def tree_unflatten(cls, aux_data, children) -&gt; Self:\n        return cls(*children)\n</code></pre>"},{"location":"reference/solutions/#jitkasi.solutions.Solution.copy","title":"<code>copy(deep=False)</code>","text":"<p>Return of copy of the Solution.</p> <p>Parameters:</p> Name Type Description Default <code>deep</code> <code>bool</code> <p>If True do a deepcopy so that all contained data is also copied. Otherwise a mostly shallow copy is made and the new Solution will reference the same objects except for <code>params</code> which will be a copy.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>copy</code> <code>Solution</code> <p>A copy of this Solution.</p> Source code in <code>jitkasi/solutions.py</code> <pre><code>def copy(self, deep: bool = False) -&gt; Self:\n    \"\"\"\n    Return of copy of the Solution.\n\n    Parameters\n    ----------\n    deep : bool, default: False\n        If True do a deepcopy so that all contained\n        data is also copied. Otherwise a mostly shallow copy is\n        made and the new Solution will reference the same objects\n        except for `params` which will be a copy.\n\n    Returns\n    -------\n    copy : Solution\n        A copy of this Solution.\n    \"\"\"\n    if deep:\n        return deepcopy(self)\n    else:\n        new = copy(self)\n        new.params = new.params.copy()\n        return new\n</code></pre>"},{"location":"reference/solutions/#jitkasi.solutions.SolutionSet","title":"<code>SolutionSet</code>  <code>dataclass</code>","text":"<p>Class to store collections of Solutions. Eventually this will be responsible for handling most collective (and MPI aware) operations on Solutions.</p> <p>Note that while this can mostly be treated like a list, '+' acts in a math like fasion adding Solutions within two SolutionSets together rather than appending them (unlike TODVec which does append).</p> <p>Attributes:</p> Name Type Description <code>solutions</code> <code>list[Solution]</code> <p>The solutions that belong to this SolutionSet. Indexing and interating the SolutionSet operates on this.</p> Source code in <code>jitkasi/solutions.py</code> <pre><code>@dataclass\nclass SolutionSet:\n    \"\"\"\n    Class to store collections of Solutions.\n    Eventually this will be responsible for handling most\n    collective (and MPI aware) operations on Solutions.\n\n    Note that while this can mostly be treated like a list, '+' acts\n    in a math like fasion adding Solutions within two SolutionSets together\n    rather than appending them (unlike TODVec which does append).\n\n    Attributes\n    ----------\n    solutions : list[Solution]\n        The solutions that belong to this SolutionSet.\n        Indexing and interating the SolutionSet operates on this.\n    \"\"\"\n\n    solutions: list[Solution] = field(default_factory=list)\n\n    def copy(self, deep: bool = False) -&gt; Self:\n        \"\"\"\n        Return of copy of the SolutionSet.\n\n        Parameters\n        ----------\n        deep : bool, default: False\n            If True do a deepcopy so that all contained\n            Solutions are also copied. Otherwise a shallow copy is\n            made and the new SolutionSet will reference the same Solutions.\n\n        Returns\n        -------\n        copy : TODVec\n            A copy of this TODVec.\n        \"\"\"\n        if deep:\n            return deepcopy(self)\n        return copy(self)\n\n    @jit\n    def to_tods(self, todvec: TODVec) -&gt; TODVec:\n        \"\"\"\n        Project the all the Solutions into the same set of TODs.\n\n        Parameters\n        ----------\n        todvec : TODVec\n            TODVec containing TODs to project into.\n            Only used for pointing and shape information,\n            not modified in place.\n\n        Returns\n        -------\n        todvec_out : TODVec\n            A TODvec each with the Solutions projected into it.\n            The order of TODs here is the same as the input TODVec\n            and the TODs within are shallow copied to the non-data\n            Arrays reference the same memory as the original TODs.\n        \"\"\"\n        todvec_out = todvec.copy(deep=False)\n        for tod in todvec_out:\n            tod.data = jnp.zeros_like(tod.data)\n        for solution in self:\n            tmp = solution.to_tods(todvec)\n            for todout, todin in zip(todvec_out, tmp):\n                todout.data = todout.data.at[:].add(todin.data.at[:].get())\n        return todvec_out\n\n    @jit\n    def from_tods(self, todvec: TODVec, use_filt: bool = True) -&gt; Self:\n        \"\"\"\n        Project TODs into the solutions.\n\n        Parameters\n        ----------\n        todvec : TODVec\n            TODVec containing TODs to project from.\n        use_filt : bool, default: True\n            If True use data_filt instead of data.\n\n        Returns\n        -------\n        solutionset_out : SolutionSet\n            A SolutionSet with the TODs projected into each Solution.\n            The new Solutions are shallow copies of the current ones so all Arrays\n            except for params reference the same memory as before.\n        \"\"\"\n        solutionset_out = self.copy(deep=False)\n        for i, solution in enumerate(self):\n            solutionset_out[i] = solution.from_tods(todvec, use_filt)\n        return solutionset_out\n\n    # Math functions\n    def __add__(self, other: Self) -&gt; Self:\n        if len(self.solutions) != other.solutions:\n            raise ValueError(\n                \"SolutionSets can only be added if they contain the same number of solutions\"\n            )\n        summed = self.copy(deep=False)\n        for i in range(len(self.solutions)):\n            summed[i] = self[i] + other[i]\n        return summed\n\n    def __sub__(self, other: Self) -&gt; Self:\n        if len(self.solutions) != other.solutions:\n            raise ValueError(\n                \"SolutionSets can only be subtracted if they contain the same number of solutions\"\n            )\n        subbed = self.copy(deep=False)\n        for i in range(len(self.solutions)):\n            subbed[i] = self[i] - other[i]\n        return subbed\n\n    def __mul__(self, other: Self) -&gt; Self:\n        if len(self.solutions) != other.solutions:\n            raise ValueError(\n                \"SolutionSets can only be multiplied if they contain the same number of solutions\"\n            )\n        product = self.copy(deep=False)\n        for i in range(len(self.solutions)):\n            product[i] = self[i] * other[i]\n        return product\n\n    @jit\n    def __matmul__(self, other: Self) -&gt; float:\n        if len(self.solutions) != other.solutions:\n            raise ValueError(\n                \"SolutionSets can only be dotted if they contain the same number of solutions\"\n            )\n        tot = 0.0\n        for lsol, rsol in zip(self, other):\n            tot += lsol @ rsol\n        return tot\n\n    # Functions to make this list like\n    def __getitem__(self, key: int) -&gt; Solution:\n        if not isinstance(key, int):\n            raise TypeError(\"SolutionSet is indexed by ints\")\n        return self.solutions[key]\n\n    def __setitem__(self, key: int, value: Solution):\n        if not isinstance(key, int):\n            raise TypeError(\"SolutionSet is indexed by ints\")\n        if not isinstance(value, Solution):\n            raise TypeError(\"SolutionSet can only store instances of Solution\")\n\n        self.solutions[key] = value\n\n    def __delitem__(self, key: int):\n        if not isinstance(key, int):\n            raise TypeError(\"SolutionSet is indexed by ints\")\n        del self.solutions[key]\n\n    def __iter__(self) -&gt; Iterator[Solution]:\n        return self.solutions.__iter__()\n\n    def insert(self, key: int, value: Solution):\n        if not isinstance(key, int):\n            raise TypeError(\"SolutionSet is indexed by ints\")\n        if not isinstance(value, Solution):\n            raise TypeError(\"SolutionSet can only store instances of Solution\")\n\n        self.solutions.insert(key, value)\n\n    def append(self, value):\n        if not isinstance(value, Solution):\n            raise TypeError(\"SolutionSet can only store instances of Solution\")\n\n        self.solutions.append(value)\n\n    # Functions for making this a pytree\n    # Don't call this on your own\n    def tree_flatten(self) -&gt; tuple[tuple, None]:\n        children = tuple(self.solutions)\n        aux_data = None\n\n        return (children, aux_data)\n\n    @classmethod\n    def tree_unflatten(cls, aux_data, children) -&gt; Self:\n        return cls(list(children))\n</code></pre>"},{"location":"reference/solutions/#jitkasi.solutions.SolutionSet.copy","title":"<code>copy(deep=False)</code>","text":"<p>Return of copy of the SolutionSet.</p> <p>Parameters:</p> Name Type Description Default <code>deep</code> <code>bool</code> <p>If True do a deepcopy so that all contained Solutions are also copied. Otherwise a shallow copy is made and the new SolutionSet will reference the same Solutions.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>copy</code> <code>TODVec</code> <p>A copy of this TODVec.</p> Source code in <code>jitkasi/solutions.py</code> <pre><code>def copy(self, deep: bool = False) -&gt; Self:\n    \"\"\"\n    Return of copy of the SolutionSet.\n\n    Parameters\n    ----------\n    deep : bool, default: False\n        If True do a deepcopy so that all contained\n        Solutions are also copied. Otherwise a shallow copy is\n        made and the new SolutionSet will reference the same Solutions.\n\n    Returns\n    -------\n    copy : TODVec\n        A copy of this TODVec.\n    \"\"\"\n    if deep:\n        return deepcopy(self)\n    return copy(self)\n</code></pre>"},{"location":"reference/solutions/#jitkasi.solutions.SolutionSet.from_tods","title":"<code>from_tods(todvec, use_filt=True)</code>","text":"<p>Project TODs into the solutions.</p> <p>Parameters:</p> Name Type Description Default <code>todvec</code> <code>TODVec</code> <p>TODVec containing TODs to project from.</p> required <code>use_filt</code> <code>bool</code> <p>If True use data_filt instead of data.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>solutionset_out</code> <code>SolutionSet</code> <p>A SolutionSet with the TODs projected into each Solution. The new Solutions are shallow copies of the current ones so all Arrays except for params reference the same memory as before.</p> Source code in <code>jitkasi/solutions.py</code> <pre><code>@jit\ndef from_tods(self, todvec: TODVec, use_filt: bool = True) -&gt; Self:\n    \"\"\"\n    Project TODs into the solutions.\n\n    Parameters\n    ----------\n    todvec : TODVec\n        TODVec containing TODs to project from.\n    use_filt : bool, default: True\n        If True use data_filt instead of data.\n\n    Returns\n    -------\n    solutionset_out : SolutionSet\n        A SolutionSet with the TODs projected into each Solution.\n        The new Solutions are shallow copies of the current ones so all Arrays\n        except for params reference the same memory as before.\n    \"\"\"\n    solutionset_out = self.copy(deep=False)\n    for i, solution in enumerate(self):\n        solutionset_out[i] = solution.from_tods(todvec, use_filt)\n    return solutionset_out\n</code></pre>"},{"location":"reference/solutions/#jitkasi.solutions.SolutionSet.to_tods","title":"<code>to_tods(todvec)</code>","text":"<p>Project the all the Solutions into the same set of TODs.</p> <p>Parameters:</p> Name Type Description Default <code>todvec</code> <code>TODVec</code> <p>TODVec containing TODs to project into. Only used for pointing and shape information, not modified in place.</p> required <p>Returns:</p> Name Type Description <code>todvec_out</code> <code>TODVec</code> <p>A TODvec each with the Solutions projected into it. The order of TODs here is the same as the input TODVec and the TODs within are shallow copied to the non-data Arrays reference the same memory as the original TODs.</p> Source code in <code>jitkasi/solutions.py</code> <pre><code>@jit\ndef to_tods(self, todvec: TODVec) -&gt; TODVec:\n    \"\"\"\n    Project the all the Solutions into the same set of TODs.\n\n    Parameters\n    ----------\n    todvec : TODVec\n        TODVec containing TODs to project into.\n        Only used for pointing and shape information,\n        not modified in place.\n\n    Returns\n    -------\n    todvec_out : TODVec\n        A TODvec each with the Solutions projected into it.\n        The order of TODs here is the same as the input TODVec\n        and the TODs within are shallow copied to the non-data\n        Arrays reference the same memory as the original TODs.\n    \"\"\"\n    todvec_out = todvec.copy(deep=False)\n    for tod in todvec_out:\n        tod.data = jnp.zeros_like(tod.data)\n    for solution in self:\n        tmp = solution.to_tods(todvec)\n        for todout, todin in zip(todvec_out, tmp):\n            todout.data = todout.data.at[:].add(todin.data.at[:].get())\n    return todvec_out\n</code></pre>"},{"location":"reference/solutions/#jitkasi.solutions.WCSMap","title":"<code>WCSMap</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Solution</code></p> <p>Class for solving for a map. Uses a WCS header for its pixel definitions. See <code>Solution</code> for inherited attributes. This class is a registered pytree so it is JITable with JAX.</p> <p>TODO: Caching and purging of pixelization</p> <p>Attributes:</p> Name Type Description <code>wcs</code> <code>WCS</code> <p>The WCS header that defines the map pixelization. This is aux data for the pytree.</p> <code>pixelization</code> <code>str</code> <p>The pixelization method used when projecting to/from TODs. Currently accepted values are: * 'nn': Nearest neighpor pixelization. This is aux data for the pytree.</p> Source code in <code>jitkasi/solutions.py</code> <pre><code>@register_pytree_node_class\n@dataclass\nclass WCSMap(Solution):\n    \"\"\"\n    Class for solving for a map.\n    Uses a WCS header for its pixel definitions.\n    See `Solution` for inherited attributes.\n    This class is a registered pytree so it is JITable with JAX.\n\n    TODO: Caching and purging of pixelization\n\n    Attributes\n    ----------\n    wcs : WCS\n        The WCS header that defines the map pixelization.\n        This is aux data for the pytree.\n    pixelization : str\n        The pixelization method used when projecting to/from TODs.\n        Currently accepted values are:\n        * 'nn': Nearest neighpor pixelization.\n        This is aux data for the pytree.\n    \"\"\"\n\n    wcs: WCS\n    pixelization: str\n    _pix_reg: dict = field(init=False, repr=False, default_factory=dict)\n\n    def __post_init__(self):\n        # Add pixelization methods to the registry\n        self._pix_reg[\"nn\"] = self.nn_pix\n        # Check that we have a valid pixelization scheme\n        if self.pixelization not in self._pix_reg.keys():\n            raise ValueError(f\"Invalid pixelization: {self.pixelization}\")\n\n    @jit\n    def nn_pix(self, tod: TOD) -&gt; Array:\n        coords = jnp.column_stack(\n            [jnp.ravel(tod.x * 180.0 / jnp.pi), jnp.ravel(tod.y * 180.0 / jnp.pi)]\n        )\n        # -1 is to go between unit offset in FITS and zero offset in python\n        pix = jnp.round(jnp.array(self.wcs.wcs_world2pix(coords, 1)) - 1.0).reshape(\n            (2,) + tod.data.shape\n        )\n        return pix.astype(jnp.int32)\n\n    @jit\n    def to_tods(self, todvec: TODVec) -&gt; TODVec:\n        \"\"\"\n        Project the map into TODs.\n\n        Parameters\n        ----------\n        todvec : TODVec\n            TODVec containing TODs to project into.\n            Only used for pointing and shape information,\n            not modified in place.\n\n        Returns\n        -------\n        todvec_out : TODVec\n            A TODvec where each with the map projected into it.\n            The order of TODs here is the same as the input TODVec\n            and the TODs within are shallow copied to the non-data\n            Arrays reference the same memory as the original TODs.\n        \"\"\"\n        todvec_out = todvec.copy(deep=False)\n        for tod in todvec_out:\n            pix = self._pix_reg[self.pixelization](tod)\n            tod.data = jnp.zeros_like(tod.data)\n            if self.pixelization == \"nn\":\n                tod.data = tod.data.at[:].add(\n                    self.params.at[pix].get(mode=\"fill\", fill_value=0.0)\n                )\n        return todvec_out\n\n    @jit\n    def from_tods(self, todvec: TODVec, use_filt: bool = True) -&gt; Self:\n        \"\"\"\n        Project TODs into a map.\n\n        Parameters\n        ----------\n        todvec : TODVec\n            TODVec containing TODs to project from.\n        use_filt : bool, defauls: True\n            If True use data_filt instead of data.\n\n        Returns\n        -------\n        wcsmap_out : WCSMap\n            A WCSmap with the TODs binned into it.\n            This is a shallow copy of the current object so all Arrays\n            except for params reference the same memory as this object.\n        \"\"\"\n        wcsmap_out = self.copy(deep=False)\n        wcsmap_out.params = jnp.zeros_like(self.params)\n        for tod in todvec:\n            pix = self._pix_reg[self.pixelization](tod)\n            data = tod.data\n            if use_filt:\n                data = tod.data_filt\n            if self.pixelization == \"nn\":\n                wcsmap_out.params = wcsmap_out.params.at[pix].add(\n                    data.at[:].get(), mode=\"drop\"\n                )\n        return wcsmap_out\n\n    @classmethod\n    def empty(\n        cls,\n        wcs: WCS,\n        lims: tuple[float, float, float, float],\n        pad=0,\n        square=False,\n        pixelization=\"nn\",\n    ) -&gt; Self:\n        \"\"\"\n        Initialize an empty map.\n\n        Parameters\n        ----------\n        wcs : WCS\n            The WCS kernel to use for this map.\n        lims : tuple[float, float, float, float]\n            The limits of the map in radians.\n            Should be (RA low, RA high, Dec low, Dec high).\n        pad : int, default: 0\n            Number of pixels to pad the map by.\n        square : bool, default: False\n            If True make the map square.\n        pixelization : str, default: 'nn'\n            The pixelization method to use.\n            See `WCSMap` documentation for more details.\n        \"\"\"\n        corners = np.zeros([4, 2])\n        corners[0, :] = [lims[0], lims[2]]\n        corners[1, :] = [lims[0], lims[3]]\n        corners[2, :] = [lims[1], lims[2]]\n        corners[3, :] = [lims[1], lims[3]]\n\n        pix_corners = np.array(wcs.wcs_world2pix(corners * 180 / jnp.pi, 1))\n        pix_corners = np.round(pix_corners)\n\n        if pix_corners.min() &lt; -0.5:\n            print(\n                \"corners seem to have gone negative in SkyMap projection.  not good, you may want to check this.\"\n            )\n        nx = int(pix_corners[:, 0].max() + pad)\n        ny = int(pix_corners[:, 1].max() + pad)\n\n        if square:\n            if nx &gt; ny:\n                ny = nx\n            else:\n                nx = ny\n        data = jnp.zeros((nx, ny))\n\n        return cls(data, wcs, pixelization)\n\n    def _self_check(self, other: Self):\n        if self.wcs != other.wcs:\n            raise ValueError(\"Cannot operate on WCSMaps that have different WCSs\")\n\n    # Functions for making this a pytree\n    # Don't call this on your own\n    def tree_flatten(self) -&gt; tuple[tuple, tuple]:\n        children = (self.params,)\n        aux_data = (self.wcs, self.pixelization)\n\n        return (children, aux_data)\n\n    @classmethod\n    def tree_unflatten(cls, aux_data, children) -&gt; Self:\n        return cls(*children, *aux_data)\n</code></pre>"},{"location":"reference/solutions/#jitkasi.solutions.WCSMap.empty","title":"<code>empty(wcs, lims, pad=0, square=False, pixelization='nn')</code>  <code>classmethod</code>","text":"<p>Initialize an empty map.</p> <p>Parameters:</p> Name Type Description Default <code>wcs</code> <code>WCS</code> <p>The WCS kernel to use for this map.</p> required <code>lims</code> <code>tuple[float, float, float, float]</code> <p>The limits of the map in radians. Should be (RA low, RA high, Dec low, Dec high).</p> required <code>pad</code> <code>int</code> <p>Number of pixels to pad the map by.</p> <code>0</code> <code>square</code> <code>bool</code> <p>If True make the map square.</p> <code>False</code> <code>pixelization</code> <code>str</code> <p>The pixelization method to use. See <code>WCSMap</code> documentation for more details.</p> <code>'nn'</code> Source code in <code>jitkasi/solutions.py</code> <pre><code>@classmethod\ndef empty(\n    cls,\n    wcs: WCS,\n    lims: tuple[float, float, float, float],\n    pad=0,\n    square=False,\n    pixelization=\"nn\",\n) -&gt; Self:\n    \"\"\"\n    Initialize an empty map.\n\n    Parameters\n    ----------\n    wcs : WCS\n        The WCS kernel to use for this map.\n    lims : tuple[float, float, float, float]\n        The limits of the map in radians.\n        Should be (RA low, RA high, Dec low, Dec high).\n    pad : int, default: 0\n        Number of pixels to pad the map by.\n    square : bool, default: False\n        If True make the map square.\n    pixelization : str, default: 'nn'\n        The pixelization method to use.\n        See `WCSMap` documentation for more details.\n    \"\"\"\n    corners = np.zeros([4, 2])\n    corners[0, :] = [lims[0], lims[2]]\n    corners[1, :] = [lims[0], lims[3]]\n    corners[2, :] = [lims[1], lims[2]]\n    corners[3, :] = [lims[1], lims[3]]\n\n    pix_corners = np.array(wcs.wcs_world2pix(corners * 180 / jnp.pi, 1))\n    pix_corners = np.round(pix_corners)\n\n    if pix_corners.min() &lt; -0.5:\n        print(\n            \"corners seem to have gone negative in SkyMap projection.  not good, you may want to check this.\"\n        )\n    nx = int(pix_corners[:, 0].max() + pad)\n    ny = int(pix_corners[:, 1].max() + pad)\n\n    if square:\n        if nx &gt; ny:\n            ny = nx\n        else:\n            nx = ny\n    data = jnp.zeros((nx, ny))\n\n    return cls(data, wcs, pixelization)\n</code></pre>"},{"location":"reference/solutions/#jitkasi.solutions.WCSMap.from_tods","title":"<code>from_tods(todvec, use_filt=True)</code>","text":"<p>Project TODs into a map.</p> <p>Parameters:</p> Name Type Description Default <code>todvec</code> <code>TODVec</code> <p>TODVec containing TODs to project from.</p> required <code>use_filt</code> <code>bool, defauls: True</code> <p>If True use data_filt instead of data.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>wcsmap_out</code> <code>WCSMap</code> <p>A WCSmap with the TODs binned into it. This is a shallow copy of the current object so all Arrays except for params reference the same memory as this object.</p> Source code in <code>jitkasi/solutions.py</code> <pre><code>@jit\ndef from_tods(self, todvec: TODVec, use_filt: bool = True) -&gt; Self:\n    \"\"\"\n    Project TODs into a map.\n\n    Parameters\n    ----------\n    todvec : TODVec\n        TODVec containing TODs to project from.\n    use_filt : bool, defauls: True\n        If True use data_filt instead of data.\n\n    Returns\n    -------\n    wcsmap_out : WCSMap\n        A WCSmap with the TODs binned into it.\n        This is a shallow copy of the current object so all Arrays\n        except for params reference the same memory as this object.\n    \"\"\"\n    wcsmap_out = self.copy(deep=False)\n    wcsmap_out.params = jnp.zeros_like(self.params)\n    for tod in todvec:\n        pix = self._pix_reg[self.pixelization](tod)\n        data = tod.data\n        if use_filt:\n            data = tod.data_filt\n        if self.pixelization == \"nn\":\n            wcsmap_out.params = wcsmap_out.params.at[pix].add(\n                data.at[:].get(), mode=\"drop\"\n            )\n    return wcsmap_out\n</code></pre>"},{"location":"reference/solutions/#jitkasi.solutions.WCSMap.to_tods","title":"<code>to_tods(todvec)</code>","text":"<p>Project the map into TODs.</p> <p>Parameters:</p> Name Type Description Default <code>todvec</code> <code>TODVec</code> <p>TODVec containing TODs to project into. Only used for pointing and shape information, not modified in place.</p> required <p>Returns:</p> Name Type Description <code>todvec_out</code> <code>TODVec</code> <p>A TODvec where each with the map projected into it. The order of TODs here is the same as the input TODVec and the TODs within are shallow copied to the non-data Arrays reference the same memory as the original TODs.</p> Source code in <code>jitkasi/solutions.py</code> <pre><code>@jit\ndef to_tods(self, todvec: TODVec) -&gt; TODVec:\n    \"\"\"\n    Project the map into TODs.\n\n    Parameters\n    ----------\n    todvec : TODVec\n        TODVec containing TODs to project into.\n        Only used for pointing and shape information,\n        not modified in place.\n\n    Returns\n    -------\n    todvec_out : TODVec\n        A TODvec where each with the map projected into it.\n        The order of TODs here is the same as the input TODVec\n        and the TODs within are shallow copied to the non-data\n        Arrays reference the same memory as the original TODs.\n    \"\"\"\n    todvec_out = todvec.copy(deep=False)\n    for tod in todvec_out:\n        pix = self._pix_reg[self.pixelization](tod)\n        tod.data = jnp.zeros_like(tod.data)\n        if self.pixelization == \"nn\":\n            tod.data = tod.data.at[:].add(\n                self.params.at[pix].get(mode=\"fill\", fill_value=0.0)\n            )\n    return todvec_out\n</code></pre>"},{"location":"reference/tod/","title":"tod","text":""},{"location":"reference/tod/#jitkasi.tod.TOD","title":"<code>TOD</code>  <code>dataclass</code>","text":"<p>Class for storing time ordered data. This class is a registered pytree so it is JITable with JAX.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>Array</code> <p>The detector data for this TOD. This is a child of the pytree.</p> <code>x</code> <code>Array</code> <p>The x sky coordinates for this TOD. Nominally this should be RA in radians. Note that eventually this may become a cached property to enable on the fly pointing reconstruction for large expiriments. This is a child of the pytree.</p> <code>y</code> <code>Array</code> <p>The y sky coordinates for this TOD. Nominally this should be Dec in radians. Note that eventually this may become a cached property to enable on the fly pointing reconstruction for large expiriments. This is a child of the pytree.</p> <code>noise</code> <code>Optional[NoiseModel]</code> <p>The noise model for this TOD. Should be None when no model is initialized. This is aux data for the pytree.</p> <code>meta</code> <code>dict</code> <p>Additional metadata associated with the TOD. This is supplied only for user convenience and should not be relied on in any <code>jitkasi</code> library code. It is intended to be used in user made scripts only. This is aux data for the pytree</p> Source code in <code>jitkasi/tod.py</code> <pre><code>@register_pytree_node_class\n@dataclass\nclass TOD:\n    \"\"\"\n    Class for storing time ordered data.\n    This class is a registered pytree so it is JITable with JAX.\n\n    Attributes\n    ----------\n    data : Array\n        The detector data for this TOD.\n        This is a child of the pytree.\n    x : Array\n        The x sky coordinates for this TOD.\n        Nominally this should be RA in radians.\n        Note that eventually this may become a cached property\n        to enable on the fly pointing reconstruction for large expiriments.\n        This is a child of the pytree.\n    y : Array\n        The y sky coordinates for this TOD.\n        Nominally this should be Dec in radians.\n        Note that eventually this may become a cached property\n        to enable on the fly pointing reconstruction for large expiriments.\n        This is a child of the pytree.\n    noise : Optional[NoiseModel]\n        The noise model for this TOD.\n        Should be None when no model is initialized.\n        This is aux data for the pytree.\n    meta : dict\n        Additional metadata associated with the TOD.\n        This is supplied **only** for user convenience and\n        should **not** be relied on in any `jitkasi` library code.\n        It is intended to be used in user made scripts only.\n        This is aux data for the pytree\n    \"\"\"\n\n    data: Array\n    x: Array\n    y: Array\n    noise: Optional[n.NoiseModel] = None\n    meta: dict = field(default_factory=dict)\n\n    def __post_init__(self):\n        # Check that all sizes are the same\n        shapes = [self.data.shape, self.x.shape, self.y.shape]\n        if not (\n            all(s[0] == shapes[0][0] for s in shapes)\n            and all(s[1] == shapes[0][1] for s in shapes)\n        ):\n            raise ValueError(\n                f\"Expected 'data', 'x', and 'y' to have the same shape but got {shapes}.\"\n            )\n\n    @property\n    def shape(self) -&gt; tuple[int, ...]:\n        \"\"\"\n        Get the shape of the TOD's data.\n\n        Returns\n        -------\n        shape : tuple[int, ....]\n            The shape of the TOD.\n        \"\"\"\n        return self.data.shape\n\n    @property\n    def lims(self) -&gt; tuple[float, float, float, float]:\n        \"\"\"\n        Get the limits of the TODs coordinates.\n\n        Returns\n        -------\n        x0 : float\n            The minimum x value.\n        x1 : float\n            The maximum x value.\n        y0 : float\n            The minimum y value.\n        y1 : float\n            The maximum y value.\n        \"\"\"\n        return (\n            float(jnp.min(self.x)),\n            float(jnp.max(self.x)),\n            float(jnp.min(self.y)),\n            float(jnp.max(self.y)),\n        )\n\n    @cached_property\n    def data_filt(self) -&gt; Array:\n        \"\"\"\n        Get a copy of the data with the noise model applied.\n        This is essentially $N^{-1}d$\n\n        Returns\n        -------\n        data_filt : Array\n            The filtered data.\n            If `self.noise` is None then this is just a copy of `self.data`.\n        \"\"\"\n        if self.noise is None:\n            return jnp.copy(self.data)\n        return self.noise.apply_noise(self.data)\n\n    def copy(self, deep: bool = False) -&gt; Self:\n        \"\"\"\n        Return of copy of the TOD.\n\n        Parameters\n        ----------\n        deep : bool, default: False\n            If True do a deepcopy so that all contained\n            data is also copied. Otherwise a shallow copy is\n            made and the new TOD will reference the same arrays.\n\n        Returns\n        -------\n        copy : TOD\n            A copy of this TOD.\n        \"\"\"\n        if deep:\n            return deepcopy(self)\n        return copy(self)\n\n    def compute_noise(\n        self,\n        noise_class: Optional[n.NoiseModel] = None,\n        data: Optional[Array] = None,\n        *args,\n        **kwargs,\n    ):\n        \"\"\"\n        Compute and set the noise model for this TOD.\n        This uses `noise_class.compute(dat=self.data...` to compute the noise.\n        Also resets the cache on `data_filt`.\n\n        Parameters\n        ----------\n        noise_class : Optional[NoiseModel] = None\n            The class to use as the noise model.\n            Nominally a class from `jitkasi.noise`.\n            If this is `None` then the class of `self.noise` is used,\n            if that is also `None` then an error is raised.\n        data : Optional[Array], default: None\n            Data to compute the noise model with.\n            If None we use `self.data`.\n        *args\n            Additional arguments to pass to `noise_class.compute`.\n        *kwargs\n            Additional keyword arguments to pass to `noise_class.compute`.\n        \"\"\"\n        self.__dict__.pop(\"data_filt\", None)\n        if noise_class is None:\n            if self.noise is None:\n                raise ValueError(\n                    \"Attempted to compute noise without specifying the noise class without self.noise set!\"\n                )\n            noise_class = self.noise.__class__\n        if data is None:\n            data = self.data\n        self.noise = noise_class.compute(data, *args, **kwargs)\n\n    # Functions for making this a pytree\n    # Don't call this on your own\n    def tree_flatten(self) -&gt; tuple[tuple, tuple]:\n        children = (self.data, self.x, self.y)\n        aux_data = (self.noise, self.meta)\n\n        return (children, aux_data)\n\n    @classmethod\n    def tree_unflatten(cls, aux_data, children) -&gt; Self:\n        return cls(*children, *aux_data)\n</code></pre>"},{"location":"reference/tod/#jitkasi.tod.TOD.data_filt","title":"<code>data_filt: Array</code>  <code>cached</code> <code>property</code>","text":"<p>Get a copy of the data with the noise model applied. This is essentially \\(N^{-1}d\\)</p> <p>Returns:</p> Name Type Description <code>data_filt</code> <code>Array</code> <p>The filtered data. If <code>self.noise</code> is None then this is just a copy of <code>self.data</code>.</p>"},{"location":"reference/tod/#jitkasi.tod.TOD.lims","title":"<code>lims: tuple[float, float, float, float]</code>  <code>property</code>","text":"<p>Get the limits of the TODs coordinates.</p> <p>Returns:</p> Name Type Description <code>x0</code> <code>float</code> <p>The minimum x value.</p> <code>x1</code> <code>float</code> <p>The maximum x value.</p> <code>y0</code> <code>float</code> <p>The minimum y value.</p> <code>y1</code> <code>float</code> <p>The maximum y value.</p>"},{"location":"reference/tod/#jitkasi.tod.TOD.shape","title":"<code>shape: tuple[int, ...]</code>  <code>property</code>","text":"<p>Get the shape of the TOD's data.</p> <p>Returns:</p> Name Type Description <code>shape</code> <code>tuple[int, ....]</code> <p>The shape of the TOD.</p>"},{"location":"reference/tod/#jitkasi.tod.TOD.compute_noise","title":"<code>compute_noise(noise_class=None, data=None, *args, **kwargs)</code>","text":"<p>Compute and set the noise model for this TOD. This uses <code>noise_class.compute(dat=self.data...</code> to compute the noise. Also resets the cache on <code>data_filt</code>.</p> <p>Parameters:</p> Name Type Description Default <code>noise_class</code> <code>Optional[NoiseModel] = None</code> <p>The class to use as the noise model. Nominally a class from <code>jitkasi.noise</code>. If this is <code>None</code> then the class of <code>self.noise</code> is used, if that is also <code>None</code> then an error is raised.</p> <code>None</code> <code>data</code> <code>Optional[Array]</code> <p>Data to compute the noise model with. If None we use <code>self.data</code>.</p> <code>None</code> <code>*args</code> <p>Additional arguments to pass to <code>noise_class.compute</code>.</p> <code>()</code> <code>*kwargs</code> <p>Additional keyword arguments to pass to <code>noise_class.compute</code>.</p> <code>{}</code> Source code in <code>jitkasi/tod.py</code> <pre><code>def compute_noise(\n    self,\n    noise_class: Optional[n.NoiseModel] = None,\n    data: Optional[Array] = None,\n    *args,\n    **kwargs,\n):\n    \"\"\"\n    Compute and set the noise model for this TOD.\n    This uses `noise_class.compute(dat=self.data...` to compute the noise.\n    Also resets the cache on `data_filt`.\n\n    Parameters\n    ----------\n    noise_class : Optional[NoiseModel] = None\n        The class to use as the noise model.\n        Nominally a class from `jitkasi.noise`.\n        If this is `None` then the class of `self.noise` is used,\n        if that is also `None` then an error is raised.\n    data : Optional[Array], default: None\n        Data to compute the noise model with.\n        If None we use `self.data`.\n    *args\n        Additional arguments to pass to `noise_class.compute`.\n    *kwargs\n        Additional keyword arguments to pass to `noise_class.compute`.\n    \"\"\"\n    self.__dict__.pop(\"data_filt\", None)\n    if noise_class is None:\n        if self.noise is None:\n            raise ValueError(\n                \"Attempted to compute noise without specifying the noise class without self.noise set!\"\n            )\n        noise_class = self.noise.__class__\n    if data is None:\n        data = self.data\n    self.noise = noise_class.compute(data, *args, **kwargs)\n</code></pre>"},{"location":"reference/tod/#jitkasi.tod.TOD.copy","title":"<code>copy(deep=False)</code>","text":"<p>Return of copy of the TOD.</p> <p>Parameters:</p> Name Type Description Default <code>deep</code> <code>bool</code> <p>If True do a deepcopy so that all contained data is also copied. Otherwise a shallow copy is made and the new TOD will reference the same arrays.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>copy</code> <code>TOD</code> <p>A copy of this TOD.</p> Source code in <code>jitkasi/tod.py</code> <pre><code>def copy(self, deep: bool = False) -&gt; Self:\n    \"\"\"\n    Return of copy of the TOD.\n\n    Parameters\n    ----------\n    deep : bool, default: False\n        If True do a deepcopy so that all contained\n        data is also copied. Otherwise a shallow copy is\n        made and the new TOD will reference the same arrays.\n\n    Returns\n    -------\n    copy : TOD\n        A copy of this TOD.\n    \"\"\"\n    if deep:\n        return deepcopy(self)\n    return copy(self)\n</code></pre>"},{"location":"reference/tod/#jitkasi.tod.TODVec","title":"<code>TODVec</code>  <code>dataclass</code>","text":"<p>Class to store collections of TODs. Eventually this will be responsible for handling most collective (and MPI aware) operations on TODs.</p> <p>Attributes:</p> Name Type Description <code>tods</code> <code>list[TOD]</code> <p>The TODs that belong to this TODVec. Indexing and interating the TODVec operates on this.</p> Source code in <code>jitkasi/tod.py</code> <pre><code>@register_pytree_node_class\n@dataclass\nclass TODVec:\n    \"\"\"\n    Class to store collections of TODs.\n    Eventually this will be responsible for handling most\n    collective (and MPI aware) operations on TODs.\n\n    Attributes\n    ----------\n    tods : list[TOD]\n        The TODs that belong to this TODVec.\n        Indexing and interating the TODVec operates on this.\n    \"\"\"\n\n    tods: list[TOD] = field(default_factory=list)\n\n    @property\n    @jit\n    def nsamp(self) -&gt; int:\n        nsamp = 0\n        for tod in self.tods:\n            nsamp += int(jnp.product(jnp.array(tod.shape), axis=None))\n        return nsamp\n\n    @property\n    def lims(self) -&gt; tuple[float, float, float, float]:\n        \"\"\"\n        Get the global limits of all the TODs coordinates.\n        Will eventually be MPI aware.\n\n        Returns\n        -------\n        x0 : float\n            The minimum x value.\n        x1 : float\n            The maximum x value.\n        y0 : float\n            The minimum y value.\n        y1 : float\n            The maximum y value.\n        \"\"\"\n        all_lims = [tod.lims for tod in self.tods]\n        all_lims = jnp.array(all_lims).reshape(-1, 4)\n        lims = jnp.max(all_lims, axis=0)\n        return tuple(lims)[:4]\n\n    def copy(self, deep: bool = False) -&gt; Self:\n        \"\"\"\n        Return of copy of the TODVec.\n\n        Parameters\n        ----------\n        deep : bool, default: False\n            If True do a deepcopy so that all contained\n            TODs are also copied. Otherwise a shallow copy is\n            made and the new TODVec will reference the same TODs.\n\n        Returns\n        -------\n        copy : TODVec\n            A copy of this TODVec.\n        \"\"\"\n        if deep:\n            return deepcopy(self)\n        return copy(self)\n\n    # Functions to make this list like\n    def __getitem__(self, key: int) -&gt; TOD:\n        if not isinstance(key, int):\n            raise TypeError(\"TODVec is indexed by ints\")\n        return self.tods[key]\n\n    def __setitem__(self, key: int, value: TOD):\n        if not isinstance(key, int):\n            raise TypeError(\"TODVec is indexed by ints\")\n        if not isinstance(value, TOD):\n            raise TypeError(\"TODVec can only store instances of TOD\")\n\n        self.tods[key] = value\n\n    def __delitem__(self, key: int):\n        if not isinstance(key, int):\n            raise TypeError(\"TODVec is indexed by ints\")\n        del self.tods[key]\n\n    def __iter__(self) -&gt; Iterator[TOD]:\n        return self.tods.__iter__()\n\n    def __add__(self, other: Self) -&gt; Self:\n        if not isinstance(other, TODVec):\n            raise TypeError(\"Can only add other TODVecs to a TODVec\")\n        new = self.copy()\n        new += other\n        return new\n\n    def __radd__(self, other: Self) -&gt; Self:\n        if not isinstance(other, TODVec):\n            raise TypeError(\"Can only add other TODVecs to a TODVec\")\n        new = other.copy()\n        new += self\n        return new\n\n    def __iadd__(self, other: Self):\n        if not isinstance(other, TODVec):\n            raise TypeError(\"Can only add other TODVecs to a TODVec\")\n        self.tods += other.tods\n        return self\n\n    def insert(self, key: int, value: TOD):\n        if not isinstance(key, int):\n            raise TypeError(\"TODVec is indexed by ints\")\n        if not isinstance(value, TOD):\n            raise TypeError(\"TODVec can only store instances of TOD\")\n\n        self.tods.insert(key, value)\n\n    def append(self, value):\n        if not isinstance(value, TOD):\n            raise TypeError(\"TODVec can only store instances of TOD\")\n\n        self.tods.append(value)\n\n    # Functions for making this a pytree\n    # Don't call this on your own\n    def tree_flatten(self) -&gt; tuple[tuple, None]:\n        children = tuple(self.tods)\n        aux_data = None\n\n        return (children, aux_data)\n\n    @classmethod\n    def tree_unflatten(cls, aux_data, children) -&gt; Self:\n        return cls(list(children))\n</code></pre>"},{"location":"reference/tod/#jitkasi.tod.TODVec.lims","title":"<code>lims: tuple[float, float, float, float]</code>  <code>property</code>","text":"<p>Get the global limits of all the TODs coordinates. Will eventually be MPI aware.</p> <p>Returns:</p> Name Type Description <code>x0</code> <code>float</code> <p>The minimum x value.</p> <code>x1</code> <code>float</code> <p>The maximum x value.</p> <code>y0</code> <code>float</code> <p>The minimum y value.</p> <code>y1</code> <code>float</code> <p>The maximum y value.</p>"},{"location":"reference/tod/#jitkasi.tod.TODVec.copy","title":"<code>copy(deep=False)</code>","text":"<p>Return of copy of the TODVec.</p> <p>Parameters:</p> Name Type Description Default <code>deep</code> <code>bool</code> <p>If True do a deepcopy so that all contained TODs are also copied. Otherwise a shallow copy is made and the new TODVec will reference the same TODs.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>copy</code> <code>TODVec</code> <p>A copy of this TODVec.</p> Source code in <code>jitkasi/tod.py</code> <pre><code>def copy(self, deep: bool = False) -&gt; Self:\n    \"\"\"\n    Return of copy of the TODVec.\n\n    Parameters\n    ----------\n    deep : bool, default: False\n        If True do a deepcopy so that all contained\n        TODs are also copied. Otherwise a shallow copy is\n        made and the new TODVec will reference the same TODs.\n\n    Returns\n    -------\n    copy : TODVec\n        A copy of this TODVec.\n    \"\"\"\n    if deep:\n        return deepcopy(self)\n    return copy(self)\n</code></pre>"}]}