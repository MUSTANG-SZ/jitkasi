{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"jitkasi","text":"<p>Like minkasi but with JAX. Don't use this, its mostly just for fun (for now)</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>tod</li> </ul>"},{"location":"reference/tod/","title":"tod","text":""},{"location":"reference/tod/#jitkasi.tod.TOD","title":"<code>TOD</code>  <code>dataclass</code>","text":"<p>Class for storing time ordered data. This class is a registered pytree so it is JITable with JAX.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>Array</code> <p>The detector data for this TOD. This is a child of the pytree.</p> <code>x</code> <code>Array</code> <p>The x sky coordinates for this TOD. Nominally this should be RA in radians. Note that eventually this may become a cached property to enable on the fly pointing reconstruction for large expiriments. This is a child of the pytree.</p> <code>y</code> <code>Array</code> <p>The y sky coordinates for this TOD. Nominally this should be Dec in radians. Note that eventually this may become a cached property to enable on the fly pointing reconstruction for large expiriments. This is a child of the pytree.</p> <code>noise</code> <code>Optional[NoiseModel]</code> <p>The noise model for this TOD. Should be None when no model is initialized. This is aux data for the pytree.</p> <code>meta</code> <code>dict</code> <p>Additional metadata associated with the TOD. This is supplied only for user convenience and should not be relied on in any <code>jitkasi</code> library code. It is intended to be used in user made scripts only. This is aux data for the pytree</p> Source code in <code>jitkasi/tod.py</code> <pre><code>@register_pytree_node_class\n@dataclass\nclass TOD:\n    \"\"\"\n    Class for storing time ordered data.\n    This class is a registered pytree so it is JITable with JAX.\n\n    Attributes\n    ----------\n    data : Array\n        The detector data for this TOD.\n        This is a child of the pytree.\n    x : Array\n        The x sky coordinates for this TOD.\n        Nominally this should be RA in radians.\n        Note that eventually this may become a cached property\n        to enable on the fly pointing reconstruction for large expiriments.\n        This is a child of the pytree.\n    y : Array\n        The y sky coordinates for this TOD.\n        Nominally this should be Dec in radians.\n        Note that eventually this may become a cached property\n        to enable on the fly pointing reconstruction for large expiriments.\n        This is a child of the pytree.\n    noise : Optional[NoiseModel]\n        The noise model for this TOD.\n        Should be None when no model is initialized.\n        This is aux data for the pytree.\n    meta : dict\n        Additional metadata associated with the TOD.\n        This is supplied **only** for user convenience and\n        should **not** be relied on in any `jitkasi` library code.\n        It is intended to be used in user made scripts only.\n        This is aux data for the pytree\n    \"\"\"\n\n    data: Array\n    x: Array\n    y: Array\n    noise: Optional[\"NoiseModel\"] = (\n        None  # TODO: Once NoiseModel is implement should be Optional[NoiseModel]\n    )\n    meta: dict = {}\n\n    def __post_init__(self):\n        # Check that all sizes are the same\n        shapes = [data.shape, x.shape, y.shape]\n        if not (\n            all(s[0] == shapes[0][0] for s in shapes)\n            and all(s[1] == shapes[0][1] for s in shape)\n        ):\n            raise ValueError(\n                f\"Expected 'data', 'x', and 'y' to have the same shape but got {shapes}.\"\n            )\n\n    @property\n    def shape(self) -&gt; tuple[int, ...]:\n        \"\"\"\n        Get the shape of the TOD's data.\n\n        Returns\n        -------\n        shape : tupe[int, ....]\n            The shape of the TOD.\n        \"\"\"\n        return self.data.shape\n\n    @property\n    def lims(self) -&gt; tuple[float, float, float, float]:\n        \"\"\"\n        Get the limits of the TODs coordinates.\n\n        Returns\n        -------\n        x0 : float\n            The minimum x value.\n        x1 : float\n            The maximum x value.\n        y0 : float\n            The minimum y value.\n        y1 : float\n            The maximum y value.\n        \"\"\"\n        return (\n            float(jnp.min(self.x)),\n            float(jnp.max(self.x)),\n            float(jnp.min(self.y)),\n            float(jnp.max(self.y)),\n        )\n\n    def copy(self, deep: bool = False) -&gt; Self:\n        \"\"\"\n        Return of copy of the TOD.\n\n        Parameters\n        ----------\n        deep : bool, default: False\n            If True do a deepcopy so that all contained\n            data is also copied. Otherwise a shallow copy is\n            made and the new TOD will reference the same arrays.\n\n        Returns\n        -------\n        copy : TOD\n            A copy of this TOD.\n        \"\"\"\n        if deep:\n            return deepcopy(self)\n        return copy(self)\n\n    # Functions for making this a pytree\n    # Don't call this on your own\n    def tree_flatten(self) -&gt; tuple[tuple, tuple]:\n        children = (self.data, self.x, self.y)\n        aux_data = (self.noise, self.meta)\n\n        return (children, aux_data)\n\n    @classmethod\n    def tree_unflatten(cls, aux_data, children) -&gt; Self:\n        return cls(*children, *aux_data)\n</code></pre>"},{"location":"reference/tod/#jitkasi.tod.TOD.lims","title":"<code>lims: tuple[float, float, float, float]</code>  <code>property</code>","text":"<p>Get the limits of the TODs coordinates.</p> <p>Returns:</p> Name Type Description <code>x0</code> <code>float</code> <p>The minimum x value.</p> <code>x1</code> <code>float</code> <p>The maximum x value.</p> <code>y0</code> <code>float</code> <p>The minimum y value.</p> <code>y1</code> <code>float</code> <p>The maximum y value.</p>"},{"location":"reference/tod/#jitkasi.tod.TOD.shape","title":"<code>shape: tuple[int, ...]</code>  <code>property</code>","text":"<p>Get the shape of the TOD's data.</p> <p>Returns:</p> Name Type Description <code>shape</code> <code>tupe[int, ....]</code> <p>The shape of the TOD.</p>"},{"location":"reference/tod/#jitkasi.tod.TOD.copy","title":"<code>copy(deep=False)</code>","text":"<p>Return of copy of the TOD.</p> <p>Parameters:</p> Name Type Description Default <code>deep</code> <code>bool</code> <p>If True do a deepcopy so that all contained data is also copied. Otherwise a shallow copy is made and the new TOD will reference the same arrays.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>copy</code> <code>TOD</code> <p>A copy of this TOD.</p> Source code in <code>jitkasi/tod.py</code> <pre><code>def copy(self, deep: bool = False) -&gt; Self:\n    \"\"\"\n    Return of copy of the TOD.\n\n    Parameters\n    ----------\n    deep : bool, default: False\n        If True do a deepcopy so that all contained\n        data is also copied. Otherwise a shallow copy is\n        made and the new TOD will reference the same arrays.\n\n    Returns\n    -------\n    copy : TOD\n        A copy of this TOD.\n    \"\"\"\n    if deep:\n        return deepcopy(self)\n    return copy(self)\n</code></pre>"},{"location":"reference/tod/#jitkasi.tod.TODVec","title":"<code>TODVec</code>  <code>dataclass</code>","text":"<p>Class to store collections of TODs. Eventually this will be responsible for handling most collective (and MPI aware) operations on TODs.</p> <p>Attributes:</p> Name Type Description <code>tods</code> <code>list[TOD]</code> <p>The TODs that belong to this TODVec. This is accessible via  <code>__getitem__</code> and <code>__setitem__</code>.</p> Source code in <code>jitkasi/tod.py</code> <pre><code>@dataclass\nclass TODVec:\n    \"\"\"\n    Class to store collections of TODs.\n    Eventually this will be responsible for handling most\n    collective (and MPI aware) operations on TODs.\n\n    Attributes\n    ----------\n    tods : list[TOD]\n        The TODs that belong to this TODVec.\n        This is accessible via  `__getitem__` and `__setitem__`.\n    \"\"\"\n\n    tods: list[TOD] = []\n\n    @property\n    def lims(self) -&gt; tuple[float, float, float, float]:\n        \"\"\"\n        Get the global limits of all the TODs coordinates.\n        Will eventually be MPI aware.\n\n        Returns\n        -------\n        x0 : float\n            The minimum x value.\n        x1 : float\n            The maximum x value.\n        y0 : float\n            The minimum y value.\n        y1 : float\n            The maximum y value.\n        \"\"\"\n        all_lims = [tod.lims for tod in self.tods]\n        all_lims = jnp.array(all_lims).reshape(-1, 4)\n        lims = jnp.max(all_lims, axis=0)\n        return tuple(lims)[:4]\n\n    def copy(self, deep: bool = False) -&gt; Self:\n        \"\"\"\n        Return of copy of the TODVec.\n\n        Parameters\n        ----------\n        deep : bool, default: False\n            If True do a deepcopy so that all contained\n            TODs are also copied. Otherwise a shallow copy is\n            made and the new TODVec will reference the same TODs.\n\n        Returns\n        -------\n        copy : TODVec\n            A copy of this TODVec.\n        \"\"\"\n        if deep:\n            return deepcopy(self)\n        return copy(self)\n\n    # Functions to make this list like\n    def __getitem__(self, key: int) -&gt; TOD:\n        if not isinstance(key, int):\n            raise TypeError(\"TODVec is indexed by ints\")\n        return self.tods[key]\n\n    def __setitem__(self, key: int, value: TOD):\n        if not isinstance(key, int):\n            raise TypeError(\"TODVec is indexed by ints\")\n        if not isinstance(value, TOD):\n            raise TypeError(\"TODVec can only store instances of TOD\")\n\n        self.tods[key] = value\n\n    def __delitem__(self, key: int):\n        if not isinstance(key, int):\n            raise TypeError(\"TODVec is indexed by ints\")\n        del self.tods[key]\n\n    def __iter__(self) -&gt; Iterable[TOD]:\n        return self.tods.__iter__()\n\n    def __add__(self, other: Self) -&gt; Self:\n        if not isinstance(other, TODVec):\n            raise TypeError(\"Can only add other TODVecs to a TODVec\")\n        new = self.copy()\n        new += other\n        return new\n\n    def __radd__(self, other: Self) -&gt; Self:\n        if not isinstance(other, TODVec):\n            raise TypeError(\"Can only add other TODVecs to a TODVec\")\n        new = other.copy()\n        new += self\n        return new\n\n    def __iadd__(self, other: Self):\n        if not isinstance(other, TODVec):\n            raise TypeError(\"Can only add other TODVecs to a TODVec\")\n        self.tods += other.tods\n        return self\n\n    def insert(self, key: int, value: TOD):\n        if not isinstance(key, int):\n            raise TypeError(\"TODVec is indexed by ints\")\n        if not isinstance(value, TOD):\n            raise TypeError(\"TODVec can only store instances of TOD\")\n\n        self.tods.insert(key, value)\n\n    def append(self, value):\n        if not isinstance(value, TOD):\n            raise TypeError(\"TODVec can only store instances of TOD\")\n\n        self.tods.append(value)\n</code></pre>"},{"location":"reference/tod/#jitkasi.tod.TODVec.lims","title":"<code>lims: tuple[float, float, float, float]</code>  <code>property</code>","text":"<p>Get the global limits of all the TODs coordinates. Will eventually be MPI aware.</p> <p>Returns:</p> Name Type Description <code>x0</code> <code>float</code> <p>The minimum x value.</p> <code>x1</code> <code>float</code> <p>The maximum x value.</p> <code>y0</code> <code>float</code> <p>The minimum y value.</p> <code>y1</code> <code>float</code> <p>The maximum y value.</p>"},{"location":"reference/tod/#jitkasi.tod.TODVec.copy","title":"<code>copy(deep=False)</code>","text":"<p>Return of copy of the TODVec.</p> <p>Parameters:</p> Name Type Description Default <code>deep</code> <code>bool</code> <p>If True do a deepcopy so that all contained TODs are also copied. Otherwise a shallow copy is made and the new TODVec will reference the same TODs.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>copy</code> <code>TODVec</code> <p>A copy of this TODVec.</p> Source code in <code>jitkasi/tod.py</code> <pre><code>def copy(self, deep: bool = False) -&gt; Self:\n    \"\"\"\n    Return of copy of the TODVec.\n\n    Parameters\n    ----------\n    deep : bool, default: False\n        If True do a deepcopy so that all contained\n        TODs are also copied. Otherwise a shallow copy is\n        made and the new TODVec will reference the same TODs.\n\n    Returns\n    -------\n    copy : TODVec\n        A copy of this TODVec.\n    \"\"\"\n    if deep:\n        return deepcopy(self)\n    return copy(self)\n</code></pre>"}]}