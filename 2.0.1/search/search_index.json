{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"jitkasi","text":"<p>Like minkasi but with JAX. Don't use this, its mostly just for fun (for now)</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>mapmaking</li> <li>math</li> <li>noise</li> <li>solutions<ul> <li>core</li> <li>maps</li> </ul> </li> <li>tod</li> </ul>"},{"location":"reference/mapmaking/","title":"mapmaking","text":"<p>Core mapmaking functions</p>"},{"location":"reference/mapmaking/#jitkasi.mapmaking.make_lhs","title":"<code>make_lhs(solutionset, todvec)</code>","text":"<p>Make the left hand side of the map maker equation: \\(P^{T}N^{-1}Pm\\). To do this we project the Solutions into TODs, apply the noise model, and project back to Solutions.</p> <p>Parameters:</p> Name Type Description Default <code>solutionset</code> <code>SolutionSet</code> <p>SolutionSet containing the things you are trying to solve for. This is not modified in place.</p> required <code>todvec</code> <code>TODVec</code> <p>TODVec containing TODs to project into and from. Only used for pointing and shape information, not modified in place.</p> required <p>Returns:</p> Name Type Description <code>lhs</code> <code>SolutionSet</code> <p>A SolutionSet for the left hand side of the map maker equation.</p> Source code in <code>jitkasi/mapmaking.py</code> <pre><code>@jit\ndef make_lhs(solutionset: SolutionSet, todvec: TODVec) -&gt; SolutionSet:\n    \"\"\"\n    Make the left hand side of the map maker equation: $P^{T}N^{-1}Pm$.\n    To do this we project the Solutions into TODs, apply the noise model,\n    and project back to Solutions.\n\n    Parameters\n    ----------\n    solutionset : SolutionSet\n        SolutionSet containing the things you are trying to solve for.\n        This is not modified in place.\n    todvec : TODVec\n        TODVec containing TODs to project into and from.\n        Only used for pointing and shape information,\n        not modified in place.\n\n    Returns\n    -------\n    lhs : SolutionSet\n        A SolutionSet for the left hand side of the map maker equation.\n    \"\"\"\n    projected = solutionset.to_tods(todvec)\n    lhs = solutionset.from_tods(projected, True)\n    return lhs\n</code></pre>"},{"location":"reference/mapmaking/#jitkasi.mapmaking.make_rhs","title":"<code>make_rhs(solutionset, todvec)</code>","text":"<p>Make the right hand side of the map maker equation: \\(P^{T}N^{-1}d\\). To do this we apply the noise model to some TODs and project into Solutions.</p> <p>Parameters:</p> Name Type Description Default <code>solutionset</code> <code>SolutionSet</code> <p>SolutionSet containing the things you are trying to solve for. This is not modified in place.</p> required <code>todvec</code> <code>TODVec</code> <p>TODVec containing TODs to project from. This is not modified in place.</p> required <p>Returns:</p> Name Type Description <code>rhs</code> <code>SolutionSet</code> <p>A SolutionSet for the right hand side of the map maker equation.</p> Source code in <code>jitkasi/mapmaking.py</code> <pre><code>@jit\ndef make_rhs(solutionset: SolutionSet, todvec: TODVec) -&gt; SolutionSet:\n    \"\"\"\n    Make the right hand side of the map maker equation: $P^{T}N^{-1}d$.\n    To do this we apply the noise model to some TODs and project into Solutions.\n\n    Parameters\n    ----------\n    solutionset : SolutionSet\n        SolutionSet containing the things you are trying to solve for.\n        This is not modified in place.\n    todvec : TODVec\n        TODVec containing TODs to project from.\n        This is not modified in place.\n\n    Returns\n    -------\n    rhs : SolutionSet\n        A SolutionSet for the right hand side of the map maker equation.\n    \"\"\"\n    rhs = solutionset.from_tods(todvec, True)\n    return rhs\n</code></pre>"},{"location":"reference/mapmaking/#jitkasi.mapmaking.run_pcg","title":"<code>run_pcg(rhs, todvec, x0, precon, maxiter=100)</code>","text":"<p>Solve using Preconditioned Conjugate Gradient (PCG). This iteratively approximates the solution to \\(Ax = b\\), where \\(A\\) is a matrix and \\(x\\) and \\(b\\) are vectors.</p> <p>In ML mapmaking we are solving \\(P^{T}N^{-1}Pm = P^{T}N^{-1}d\\) so \\(m\\) is \\(x\\) in the general linear equation and is what we are solving for (usually a map, but perhaps some simultanious terms such as cuts).</p> <p>Parameters:</p> Name Type Description Default <code>rhs</code> <code>SolutionSet</code> <p>The right hand side of the mapmaker equation: \\(P^{T}N{-1}d\\). This is \\(b\\) in the general linear equation.</p> required <code>todvec</code> <code>TODvec</code> <p>TODVec containing the TODs we are solving with. This is \\(d\\) in the mapmaker equation.</p> required <code>x0</code> <code>SolutionSet</code> <p>Initial guess for the solution.</p> required <code>precon</code> <code>SolutionsSet</code> <p>Preconditioner to apply at easy iteration. This makes things more invertible.</p> required <code>maxiter</code> <code>int</code> <p>The number of PCG iters to run</p> <code>100</code> <p>Returns:</p> Name Type Description <code>x</code> <code>SolutionSet</code> <p>The solved SolutionSet. This is \\(m\\) in the mapmaker equation.</p> Source code in <code>jitkasi/mapmaking.py</code> <pre><code>def run_pcg(\n    rhs: SolutionSet,\n    todvec: TODVec,\n    x0: SolutionSet,\n    precon: SolutionSet,\n    maxiter: int = 100,\n) -&gt; SolutionSet:\n    \"\"\"\n    Solve using Preconditioned Conjugate Gradient (PCG).\n    This iteratively approximates the solution to $Ax = b$,\n    where $A$ is a matrix and $x$ and $b$ are vectors.\n\n    In ML mapmaking we are solving $P^{T}N^{-1}Pm = P^{T}N^{-1}d$\n    so $m$ is $x$ in the general linear equation and is what we are solving for\n    (usually a map, but perhaps some simultanious terms such as cuts).\n\n    Parameters\n    ----------\n    rhs : SolutionSet\n        The right hand side of the mapmaker equation: $P^{T}N{-1}d$.\n        This is $b$ in the general linear equation.\n    todvec : TODvec\n        TODVec containing the TODs we are solving with.\n        This is $d$ in the mapmaker equation.\n    x0 : SolutionSet\n        Initial guess for the solution.\n    precon : SolutionsSet\n        Preconditioner to apply at easy iteration.\n        This makes things more invertible.\n    maxiter : int, default: 100\n        The number of PCG iters to run\n\n\n    Returns\n    -------\n    x : SolutionSet\n        The solved SolutionSet.\n        This is $m$ in the mapmaker equation.\n    \"\"\"\n    lhs = make_lhs(x0, todvec)\n\n    # compute the remainder r_0\n    r = rhs - lhs\n    z = precon * r\n\n    # Initial p_0 = z_0 = M*r_0\n    p = z.copy(deep=True)\n\n    # compute z*r, which is used for computing alpha\n    zr = r @ z\n    # make a copy of our initial guess\n    x = x0.copy(deep=True)\n\n    # Run for maxiter steps\n    todvec, precon, p, x, r, zr = lax.fori_loop(\n        0, maxiter, _pcg_step, (todvec, precon, p, x, r, zr), unroll=True\n    )\n\n    return x\n</code></pre>"},{"location":"reference/math/","title":"math","text":"<p>Generically useful JITted math functions</p>"},{"location":"reference/math/#jitkasi.math.dct_i","title":"<code>dct_i(dat, inv=False, axis=-1)</code>","text":"<p>Compute the 1d discrete cosine transform (DCT) of the first kind.</p> <p>Note that since this uses <code>rfft</code> to compute the DCT this suffers from slightly lower accuracy than a proper DCT such at the <code>fftw</code> or <code>scipy</code> ones. Passing white noise back and forth through this function results in errors at the \\(1e-7\\) level.</p> <p>Parameters:</p> Name Type Description Default <code>dat</code> <code>Array</code> <p>The data to DCT. If this is multidimensional the DCT is computed along only <code>axis</code>.</p> required <code>inv</code> <code>bool, defualt: False</code> <p>If True apply the \\(\\frac{1}{2*(n-1)}\\) normalization that turns this into the inverse DCT.</p> <code>False</code> <code>axis</code> <code>int, defualt: -1</code> <p>The axis to compute the DCT along.</p> <code>-1</code> <p>Returns:</p> Name Type Description <code>dat_dct</code> <code>Array</code> <p>The DCT of the first kind of <code>dat</code>. Has the same shape and dtype as <code>dat</code>.</p> Source code in <code>jitkasi/math.py</code> <pre><code>@jit\ndef dct_i(dat: Array, inv: bool = False, axis: int = -1) -&gt; Array:\n    r\"\"\"\n    Compute the 1d discrete cosine transform (DCT) of the first kind.\n\n    Note that since this uses `rfft` to compute the DCT this suffers from\n    slightly lower accuracy than a proper DCT such at the `fftw` or `scipy` ones.\n    Passing white noise back and forth through this function results in errors\n    at the $1e-7$ level.\n\n    Parameters\n    ----------\n    dat : Array\n        The data to DCT.\n        If this is multidimensional the DCT is computed along only `axis`.\n    inv : bool, defualt: False\n        If True apply the $\\frac{1}{2*(n-1)}$ normalization that turns this into\n        the inverse DCT.\n    axis : int, defualt: -1\n        The axis to compute the DCT along.\n\n    Returns\n    -------\n    dat_dct : Array\n        The DCT of the first kind of `dat`.\n        Has the same shape and dtype as `dat`.\n    \"\"\"\n    s = dat.shape\n    dat = jnp.atleast_2d(dat)\n    dat_tmp = jnp.hstack([dat, jnp.fliplr(dat[:, 1:-1])])\n    dat_dct = jnp.real(jnp.fft.rfft(dat_tmp))\n    dat_dct = lax.select(\n        inv, dat_dct.at[:].multiply(1.0 / (2 * (dat.shape[axis] - 1))), dat_dct\n    )\n    return dat_dct.reshape(s)\n</code></pre>"},{"location":"reference/math/#jitkasi.math.gauss_smooth_1d","title":"<code>gauss_smooth_1d(dat, fwhm)</code>","text":"<p>Smooth an array along its last axis with a gaussian. If you want to smooth along another axis consider using <code>roll</code> or <code>moveaxis</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dat</code> <code>Array</code> <p>The data to smooth.</p> required <code>fwmh</code> <code>float</code> <p>The full width half max of the gaussian used to smooth.</p> required <p>Returns:</p> Name Type Description <code>dat_smooth</code> <code>Array</code> <p>The smoothed data. Has the same shape and dtype as <code>dat</code>.</p> Source code in <code>jitkasi/math.py</code> <pre><code>@jit\ndef gauss_smooth_1d(dat: Array, fwhm: float) -&gt; Array:\n    \"\"\"\n    Smooth an array along its last axis with a gaussian.\n    If you want to smooth along another axis consider using `roll` or `moveaxis`.\n\n    Parameters\n    ----------\n    dat : Array\n        The data to smooth.\n    fwmh : float\n        The full width half max of the gaussian used to smooth.\n\n    Returns\n    -------\n    dat_smooth : Array\n        The smoothed data.\n        Has the same shape and dtype as `dat`.\n    \"\"\"\n    smooth_kern = jnp.exp(\n        -0.5 * (jnp.arange(dat.shape[-1]) * jnp.sqrt(8 * jnp.log(2)) / fwhm) ** 2\n    )\n    tot = smooth_kern[0] + smooth_kern[-1] + 2 * jnp.sum(smooth_kern[1:-1])\n    smooth_kern = smooth_kern.at[:].multiply(1.0 / tot)\n    smooth_kern = dct_i(smooth_kern)\n    dat_smooth = dct_i(dat)\n    dat_smooth = dat_smooth.at[:].multiply(smooth_kern)\n    dat_smooth = dct_i(dat_smooth, True)\n\n    return dat_smooth\n</code></pre>"},{"location":"reference/noise/","title":"noise","text":""},{"location":"reference/noise/#jitkasi.noise.NoiseI","title":"<code>NoiseI</code>  <code>dataclass</code>","text":"<p>A dummy noise class that does nothing. This is the equivalent of having the noise covariance be the identity.</p> Source code in <code>jitkasi/noise.py</code> <pre><code>@register_pytree_node_class\n@dataclass\nclass NoiseI:\n    \"\"\"\n    A dummy noise class that does nothing.\n    This is the equivalent of having the noise covariance be the identity.\n    \"\"\"\n\n    def apply_noise(self, dat: Array) -&gt; Array:\n        \"\"\"\n        Just returns `dat` back to you.\n\n        Parameters\n        ----------\n        dat : Array\n            The input data.\n\n        Returns\n        -------\n        dat : Array\n            The exact same thing as the input `dat`.\n            This is not a copy.\n        \"\"\"\n        return dat\n\n    @classmethod\n    def compute(cls, dat: Array) -&gt; Self:\n        \"\"\"\n        Initialize an instance of this class.\n\n        Parameters\n        ----------\n        dat : Array\n            Unused, just here for API compatibility.\n        \"\"\"\n        _ = dat\n        return cls()\n\n    # Functions for making this a pytree\n    # Don't call this on your own\n    def tree_flatten(self) -&gt; tuple[None, None]:\n        children = None\n        aux_data = None\n\n        return (children, aux_data)\n\n    @classmethod\n    def tree_unflatten(cls, aux_data, children) -&gt; Self:\n        del aux_data\n        del children\n        return cls()\n</code></pre>"},{"location":"reference/noise/#jitkasi.noise.NoiseI.apply_noise","title":"<code>apply_noise(dat)</code>","text":"<p>Just returns <code>dat</code> back to you.</p> <p>Parameters:</p> Name Type Description Default <code>dat</code> <code>Array</code> <p>The input data.</p> required <p>Returns:</p> Name Type Description <code>dat</code> <code>Array</code> <p>The exact same thing as the input <code>dat</code>. This is not a copy.</p> Source code in <code>jitkasi/noise.py</code> <pre><code>def apply_noise(self, dat: Array) -&gt; Array:\n    \"\"\"\n    Just returns `dat` back to you.\n\n    Parameters\n    ----------\n    dat : Array\n        The input data.\n\n    Returns\n    -------\n    dat : Array\n        The exact same thing as the input `dat`.\n        This is not a copy.\n    \"\"\"\n    return dat\n</code></pre>"},{"location":"reference/noise/#jitkasi.noise.NoiseI.compute","title":"<code>compute(dat)</code>  <code>classmethod</code>","text":"<p>Initialize an instance of this class.</p> <p>Parameters:</p> Name Type Description Default <code>dat</code> <code>Array</code> <p>Unused, just here for API compatibility.</p> required Source code in <code>jitkasi/noise.py</code> <pre><code>@classmethod\ndef compute(cls, dat: Array) -&gt; Self:\n    \"\"\"\n    Initialize an instance of this class.\n\n    Parameters\n    ----------\n    dat : Array\n        Unused, just here for API compatibility.\n    \"\"\"\n    _ = dat\n    return cls()\n</code></pre>"},{"location":"reference/noise/#jitkasi.noise.NoiseSmoothedSVD","title":"<code>NoiseSmoothedSVD</code>  <code>dataclass</code>","text":"<p>The standard \"Jon style\" noise model. Here we use the SVD to compute the noise spectrum. This is assuming that we are operating on noise dominated data. This class is a registered pytree so it is JITable with JAX.</p> <p>While this model is applied in fourier space it appears to be mathematically the same as if we computed \\(N^{-1}\\) directly from the SVD and then dotted that into the data being filtered. Math showing this (if actually true) will exist in the docs one day...</p> <p>Attributes:</p> Name Type Description <code>v</code> <code>Array</code> <p>The right singular vectors to of the modeled noise. This is used to rotate any input data into the space of the noise. This is a child of the pytree.</p> <code>filt_spectrum</code> <code>Array</code> <p>The inverse of the smoothed sepctrum of the noise model. This is used as a filter to remove the modeled noise in fourier space.</p> Source code in <code>jitkasi/noise.py</code> <pre><code>@register_pytree_node_class\n@dataclass\nclass NoiseSmoothedSVD:\n    \"\"\"\n    The standard \"Jon style\" noise model.\n    Here we use the SVD to compute the noise spectrum.\n    This is assuming that we are operating on noise dominated data.\n    This class is a registered pytree so it is JITable with JAX.\n\n    While this model is applied in fourier space it appears to be mathematically\n    the same as if we computed $N^{-1}$ directly from the SVD and then dotted that\n    into the data being filtered. Math showing this (if actually true) will exist\n    in the docs one day...\n\n    Attributes\n    ----------\n    v : Array\n        The right singular vectors to of the modeled noise.\n        This is used to rotate any input data into the space of the noise.\n        This is a child of the pytree.\n    filt_spectrum : Array\n        The inverse of the smoothed sepctrum of the noise model.\n        This is used as a filter to remove the modeled noise in fourier space.\n    \"\"\"\n\n    v: Array\n    filt_spectrum: Array\n\n    @jit\n    def apply_noise(self, dat: Array) -&gt; Array:\n        \"\"\"\n        Apply the noise model.\n        The procedure here is to rotate the data into the space of the noise,\n        then filter out the noise in fourier space, and then rotate back.\n\n        Parameters\n        ----------\n        dat : Array\n            The data to apply the noise model to.\n            Should be 2d with `dat.shape[0] == len(self.weights)`.\n\n        Returns\n        -------\n        dat_filt : Array\n            The data with the noise model applied.\n        \"\"\"\n        dat_rot = jnp.dot(self.v, dat)\n        dat_rft = jm.dct_i(dat_rot)\n        dat_filt = jm.dct_i(\n            dat_rft.at[:].multiply(self.filt_spectrum[:, : dat_rft.shape[1]]), False\n        )\n        dat_filt = dat_filt.at[:].set(jnp.dot(self.v.T, dat_filt))\n        dat_filt = dat_filt.at[:, 0].multiply(0.50)\n        dat_filt = dat_filt.at[:, -1].multiply(0.50)\n        return dat_filt\n\n    @classmethod\n    @partial(jit, static_argnums=(0,))\n    def compute(cls, dat: Array, fwhm: float) -&gt; Self:\n        \"\"\"\n        Compute this noise model based on some input data.\n        To do this we compute the SVD of the data, rotate into its sigular space,\n        and then compute the spectrum of each rotated detector.\n        These spectra are then smoothed and a filter a made by squaring and\n        inverting the smoothed filter.\n\n        Parameters\n        ----------\n        dat : Array\n            The data to estimate the white noise levels from.\n            Should be a 2d array.\n\n        Returns\n        -------\n        noise_model : NoiseSmoothedSVD\n            An instance of NoiseSmoothedSVD with the computed noise model.\n        \"\"\"\n        u, *_ = jnp.linalg.svd(dat, True)\n        v = u.T\n        dat_rot = jnp.dot(v, dat)\n        dat_ft = jm.dct_i(dat_rot)\n        dat_ft = dat_ft.at[:].set(jm.gauss_smooth_1d(dat_ft**2, fwhm))\n        dat_ft = dat_ft.at[:, 1:].set(1.0 / dat_ft[:, 1:])\n        dat_ft = dat_ft.at[:, 0].set(0)\n        return cls(v, dat_ft)\n\n    # Functions for making this a pytree\n    # Don't call this on your own\n    def tree_flatten(self) -&gt; tuple[tuple, None]:\n        children = (self.v, self.filt_spectrum)\n        aux_data = None\n\n        return (children, aux_data)\n\n    @classmethod\n    def tree_unflatten(cls, aux_data, children) -&gt; Self:\n        del aux_data\n        return cls(*children)\n</code></pre>"},{"location":"reference/noise/#jitkasi.noise.NoiseSmoothedSVD.apply_noise","title":"<code>apply_noise(dat)</code>","text":"<p>Apply the noise model. The procedure here is to rotate the data into the space of the noise, then filter out the noise in fourier space, and then rotate back.</p> <p>Parameters:</p> Name Type Description Default <code>dat</code> <code>Array</code> <p>The data to apply the noise model to. Should be 2d with <code>dat.shape[0] == len(self.weights)</code>.</p> required <p>Returns:</p> Name Type Description <code>dat_filt</code> <code>Array</code> <p>The data with the noise model applied.</p> Source code in <code>jitkasi/noise.py</code> <pre><code>@jit\ndef apply_noise(self, dat: Array) -&gt; Array:\n    \"\"\"\n    Apply the noise model.\n    The procedure here is to rotate the data into the space of the noise,\n    then filter out the noise in fourier space, and then rotate back.\n\n    Parameters\n    ----------\n    dat : Array\n        The data to apply the noise model to.\n        Should be 2d with `dat.shape[0] == len(self.weights)`.\n\n    Returns\n    -------\n    dat_filt : Array\n        The data with the noise model applied.\n    \"\"\"\n    dat_rot = jnp.dot(self.v, dat)\n    dat_rft = jm.dct_i(dat_rot)\n    dat_filt = jm.dct_i(\n        dat_rft.at[:].multiply(self.filt_spectrum[:, : dat_rft.shape[1]]), False\n    )\n    dat_filt = dat_filt.at[:].set(jnp.dot(self.v.T, dat_filt))\n    dat_filt = dat_filt.at[:, 0].multiply(0.50)\n    dat_filt = dat_filt.at[:, -1].multiply(0.50)\n    return dat_filt\n</code></pre>"},{"location":"reference/noise/#jitkasi.noise.NoiseSmoothedSVD.compute","title":"<code>compute(dat, fwhm)</code>  <code>classmethod</code>","text":"<p>Compute this noise model based on some input data. To do this we compute the SVD of the data, rotate into its sigular space, and then compute the spectrum of each rotated detector. These spectra are then smoothed and a filter a made by squaring and inverting the smoothed filter.</p> <p>Parameters:</p> Name Type Description Default <code>dat</code> <code>Array</code> <p>The data to estimate the white noise levels from. Should be a 2d array.</p> required <p>Returns:</p> Name Type Description <code>noise_model</code> <code>NoiseSmoothedSVD</code> <p>An instance of NoiseSmoothedSVD with the computed noise model.</p> Source code in <code>jitkasi/noise.py</code> <pre><code>@classmethod\n@partial(jit, static_argnums=(0,))\ndef compute(cls, dat: Array, fwhm: float) -&gt; Self:\n    \"\"\"\n    Compute this noise model based on some input data.\n    To do this we compute the SVD of the data, rotate into its sigular space,\n    and then compute the spectrum of each rotated detector.\n    These spectra are then smoothed and a filter a made by squaring and\n    inverting the smoothed filter.\n\n    Parameters\n    ----------\n    dat : Array\n        The data to estimate the white noise levels from.\n        Should be a 2d array.\n\n    Returns\n    -------\n    noise_model : NoiseSmoothedSVD\n        An instance of NoiseSmoothedSVD with the computed noise model.\n    \"\"\"\n    u, *_ = jnp.linalg.svd(dat, True)\n    v = u.T\n    dat_rot = jnp.dot(v, dat)\n    dat_ft = jm.dct_i(dat_rot)\n    dat_ft = dat_ft.at[:].set(jm.gauss_smooth_1d(dat_ft**2, fwhm))\n    dat_ft = dat_ft.at[:, 1:].set(1.0 / dat_ft[:, 1:])\n    dat_ft = dat_ft.at[:, 0].set(0)\n    return cls(v, dat_ft)\n</code></pre>"},{"location":"reference/noise/#jitkasi.noise.NoiseWhite","title":"<code>NoiseWhite</code>  <code>dataclass</code>","text":"<p>A simple noise model with only white noise. This is equivalent to a diagonal \\(N^{-1}\\). This class is a registered pytree so it is JITable with JAX.</p> <p>Attributes:</p> Name Type Description <code>weights</code> <code>Array</code> <p>The per-detector weights conputed from the white noise. This is a child of the pytree.</p> Source code in <code>jitkasi/noise.py</code> <pre><code>@register_pytree_node_class\n@dataclass\nclass NoiseWhite:\n    \"\"\"\n    A simple noise model with only white noise.\n    This is equivalent to a diagonal $N^{-1}$.\n    This class is a registered pytree so it is JITable with JAX.\n\n    Attributes\n    ----------\n    weights: Array\n        The per-detector weights conputed from the white noise.\n        This is a child of the pytree.\n    \"\"\"\n\n    weights: Array\n\n    @jit\n    def apply_noise(self, dat: Array) -&gt; Array:\n        \"\"\"\n        Apply the noise model.\n        In this case this is just rescaling each detector by its weight.\n\n        Parameters\n        ----------\n        dat : Array\n            The data to apply the noise model to.\n            Should be 2d with `dat.shape[0] == len(self.weights)`.\n\n        Returns\n        -------\n        dat_filt : Array\n            The data with the noise model applied.\n        \"\"\"\n        return dat * self.weights[..., None]\n\n    @classmethod\n    @partial(jit, static_argnums=(0,))\n    def compute(cls, dat: Array) -&gt; Self:\n        \"\"\"\n        Compute this noise model based on some input data.\n        Here we just estimate the variance of each detector in dat.\n\n        Parameters\n        ----------\n        dat : Array\n            The data to estimate the white noise levels from.\n            Should be a 2d array.\n\n        Returns\n        -------\n        noise_model : NoiseWhite\n            An instance of NoiseWhite with the computed noise model.\n        \"\"\"\n        weights = (\n            2 * erfinv(0.5) / jnp.median(jnp.abs(jnp.diff(dat, axis=1)), axis=1)\n        ) ** 2\n        return cls(weights)\n\n    # Functions for making this a pytree\n    # Don't call this on your own\n    def tree_flatten(self) -&gt; tuple[tuple, None]:\n        children = (self.weights,)\n        aux_data = None\n\n        return (children, aux_data)\n\n    @classmethod\n    def tree_unflatten(cls, aux_data, children) -&gt; Self:\n        del aux_data\n        return cls(*children)\n</code></pre>"},{"location":"reference/noise/#jitkasi.noise.NoiseWhite.apply_noise","title":"<code>apply_noise(dat)</code>","text":"<p>Apply the noise model. In this case this is just rescaling each detector by its weight.</p> <p>Parameters:</p> Name Type Description Default <code>dat</code> <code>Array</code> <p>The data to apply the noise model to. Should be 2d with <code>dat.shape[0] == len(self.weights)</code>.</p> required <p>Returns:</p> Name Type Description <code>dat_filt</code> <code>Array</code> <p>The data with the noise model applied.</p> Source code in <code>jitkasi/noise.py</code> <pre><code>@jit\ndef apply_noise(self, dat: Array) -&gt; Array:\n    \"\"\"\n    Apply the noise model.\n    In this case this is just rescaling each detector by its weight.\n\n    Parameters\n    ----------\n    dat : Array\n        The data to apply the noise model to.\n        Should be 2d with `dat.shape[0] == len(self.weights)`.\n\n    Returns\n    -------\n    dat_filt : Array\n        The data with the noise model applied.\n    \"\"\"\n    return dat * self.weights[..., None]\n</code></pre>"},{"location":"reference/noise/#jitkasi.noise.NoiseWhite.compute","title":"<code>compute(dat)</code>  <code>classmethod</code>","text":"<p>Compute this noise model based on some input data. Here we just estimate the variance of each detector in dat.</p> <p>Parameters:</p> Name Type Description Default <code>dat</code> <code>Array</code> <p>The data to estimate the white noise levels from. Should be a 2d array.</p> required <p>Returns:</p> Name Type Description <code>noise_model</code> <code>NoiseWhite</code> <p>An instance of NoiseWhite with the computed noise model.</p> Source code in <code>jitkasi/noise.py</code> <pre><code>@classmethod\n@partial(jit, static_argnums=(0,))\ndef compute(cls, dat: Array) -&gt; Self:\n    \"\"\"\n    Compute this noise model based on some input data.\n    Here we just estimate the variance of each detector in dat.\n\n    Parameters\n    ----------\n    dat : Array\n        The data to estimate the white noise levels from.\n        Should be a 2d array.\n\n    Returns\n    -------\n    noise_model : NoiseWhite\n        An instance of NoiseWhite with the computed noise model.\n    \"\"\"\n    weights = (\n        2 * erfinv(0.5) / jnp.median(jnp.abs(jnp.diff(dat, axis=1)), axis=1)\n    ) ** 2\n    return cls(weights)\n</code></pre>"},{"location":"reference/noise/#jitkasi.noise.NoiseWrapper","title":"<code>NoiseWrapper</code>  <code>dataclass</code>","text":"<p>Wrapper to use external noise models in <code>jitkasi</code>.</p> <p>Be warned that while this is provided we cannot gaurentee that the external class will play nicely with the rest of the library. In particular while the wrapper for <code>apply_noise</code> is set up to be called from a jitted function, <code>compute</code> is not since it includes some non-pure actions.</p> <p>Attributes:</p> Name Type Description <code>ext_inst</code> <code>Callable</code> <p>The instance of the external noise model class we are wrapping.</p> <code>apply_func</code> <code>str</code> <p>The name of the function in <code>ext_inst</code> that applies noise. We expect this to take a single 2d array as an argument.</p> <code>jitted</code> <code>bool</code> <p>Whether or not the external noise class JITs its functions. If this is False you should be very caruful about how you use this class.</p> <code>shape_dtypes</code> <code>ShapeDtypeStruct</code> <p>The shape and dtype of the array that the <code>apply_func</code> expects. This is really only used so what we can call <code>apply_func</code> when we aren't jitted.</p> Source code in <code>jitkasi/noise.py</code> <pre><code>@register_pytree_node_class\n@dataclass\nclass NoiseWrapper:\n    \"\"\"\n    Wrapper to use external noise models in `jitkasi`.\n\n    Be warned that while this is provided we cannot gaurentee that the external class\n    will play nicely with the rest of the library.\n    In particular while the wrapper for `apply_noise` is set up to be called from a jitted function,\n    `compute` is not since it includes some non-pure actions.\n\n    Attributes\n    ----------\n    ext_inst : Callable\n        The instance of the external noise model class we are wrapping.\n    apply_func : str\n        The name of the function in `ext_inst` that applies noise.\n        We expect this to take a single 2d array as an argument.\n    jitted : bool\n        Whether or not the external noise class JITs its functions.\n        If this is False you should be very caruful about how you use this class.\n    shape_dtypes : ShapeDtypeStruct\n        The shape and dtype of the array that the `apply_func` expects.\n        This is really only used so what we can call `apply_func` when we aren't jitted.\n    \"\"\"\n\n    ext_inst: Callable\n    apply_func: str\n    jitted: bool\n    shape_dtypes: ShapeDtypeStruct\n\n    def __post_init__(self):\n        if not self.jitted:\n            warnings.warn(\n                \"Initialized a non-JIT noise class! This is not supported in all usecases, proceed with caution.\"\n            )\n\n    def apply_noise(self, dat: Array) -&gt; Array:\n        \"\"\"\n        Apply the external noise model.\n        This should be safe to call from jitted functions.\n\n        Parameters\n        ----------\n        dat : Array\n            The data to apply the noise model to.\n            Should have shape and dtype that matches the `shape_dtypes` attribute.\n\n        Returns\n        -------\n        dat_filt : Array\n            The data with the noise model applied.\n        \"\"\"\n        if self.jitted:\n            return getattr(self.ext_inst, self.apply_func)(dat)\n        return pure_callback(\n            getattr(self.ext_inst, self.apply_func), self.shape_dtypes, dat\n        )\n\n    @classmethod\n    def compute(\n        cls,\n        dat: Array,\n        ext_class: Callable,\n        compute_func: str,\n        apply_func: str,\n        jitted: bool,\n        *args,\n        **kwargs,\n    ) -&gt; Self:\n        \"\"\"\n        Make an instance of the external noise class and make an instance of this class to wrap it.\n\n        Parameters\n        ----------\n        dat : Array\n            The data to compute the noise model with.\n        ext_class : Callable\n            The external noise model class.\n            Must have a class method (`__call__` is acceptable) that will create an instance\n            and compute the noise model.\n        compute_func : str\n            The function that computes an instance of the external noise model.\n            Should take `dat` as its first argument.\n        apply_func : str\n            The function that applies the noise model to some data.\n        jitted : str\n            Whether or not the external noise class JITs its own functions.\n        *args\n            Additional arguments to pass to `compute_func`.\n        **kwargs\n            Additional keyword arguments to pass to `compute_func`.\n\n        Returns\n        -------\n        noise_model : NoiseWrapper\n            An instance of `NoiseWrapper` that wraps an instance of `ext_class`.\n        \"\"\"\n        shape_dtypes = ShapeDtypeStruct(dat.shape, dat.dtype)\n        data: Array | NDArray = dat\n        if not jitted:\n            data = np.array(dat)\n        inst = getattr(ext_class, compute_func)(data, *args, **kwargs)\n        return cls(inst, apply_func, jitted, shape_dtypes)\n\n    # Functions for making this a pytree\n    # Don't call this on your own\n    def tree_flatten(self) -&gt; tuple[None, tuple]:\n        children = None\n        aux_data = (self.ext_inst, self.apply_func, self.jitted, self.shape_dtypes)\n\n        return (children, aux_data)\n\n    @classmethod\n    def tree_unflatten(cls, aux_data, children) -&gt; Self:\n        del children\n        return cls(*aux_data)\n</code></pre>"},{"location":"reference/noise/#jitkasi.noise.NoiseWrapper.apply_noise","title":"<code>apply_noise(dat)</code>","text":"<p>Apply the external noise model. This should be safe to call from jitted functions.</p> <p>Parameters:</p> Name Type Description Default <code>dat</code> <code>Array</code> <p>The data to apply the noise model to. Should have shape and dtype that matches the <code>shape_dtypes</code> attribute.</p> required <p>Returns:</p> Name Type Description <code>dat_filt</code> <code>Array</code> <p>The data with the noise model applied.</p> Source code in <code>jitkasi/noise.py</code> <pre><code>def apply_noise(self, dat: Array) -&gt; Array:\n    \"\"\"\n    Apply the external noise model.\n    This should be safe to call from jitted functions.\n\n    Parameters\n    ----------\n    dat : Array\n        The data to apply the noise model to.\n        Should have shape and dtype that matches the `shape_dtypes` attribute.\n\n    Returns\n    -------\n    dat_filt : Array\n        The data with the noise model applied.\n    \"\"\"\n    if self.jitted:\n        return getattr(self.ext_inst, self.apply_func)(dat)\n    return pure_callback(\n        getattr(self.ext_inst, self.apply_func), self.shape_dtypes, dat\n    )\n</code></pre>"},{"location":"reference/noise/#jitkasi.noise.NoiseWrapper.compute","title":"<code>compute(dat, ext_class, compute_func, apply_func, jitted, *args, **kwargs)</code>  <code>classmethod</code>","text":"<p>Make an instance of the external noise class and make an instance of this class to wrap it.</p> <p>Parameters:</p> Name Type Description Default <code>dat</code> <code>Array</code> <p>The data to compute the noise model with.</p> required <code>ext_class</code> <code>Callable</code> <p>The external noise model class. Must have a class method (<code>__call__</code> is acceptable) that will create an instance and compute the noise model.</p> required <code>compute_func</code> <code>str</code> <p>The function that computes an instance of the external noise model. Should take <code>dat</code> as its first argument.</p> required <code>apply_func</code> <code>str</code> <p>The function that applies the noise model to some data.</p> required <code>jitted</code> <code>str</code> <p>Whether or not the external noise class JITs its own functions.</p> required <code>*args</code> <p>Additional arguments to pass to <code>compute_func</code>.</p> <code>()</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to <code>compute_func</code>.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>noise_model</code> <code>NoiseWrapper</code> <p>An instance of <code>NoiseWrapper</code> that wraps an instance of <code>ext_class</code>.</p> Source code in <code>jitkasi/noise.py</code> <pre><code>@classmethod\ndef compute(\n    cls,\n    dat: Array,\n    ext_class: Callable,\n    compute_func: str,\n    apply_func: str,\n    jitted: bool,\n    *args,\n    **kwargs,\n) -&gt; Self:\n    \"\"\"\n    Make an instance of the external noise class and make an instance of this class to wrap it.\n\n    Parameters\n    ----------\n    dat : Array\n        The data to compute the noise model with.\n    ext_class : Callable\n        The external noise model class.\n        Must have a class method (`__call__` is acceptable) that will create an instance\n        and compute the noise model.\n    compute_func : str\n        The function that computes an instance of the external noise model.\n        Should take `dat` as its first argument.\n    apply_func : str\n        The function that applies the noise model to some data.\n    jitted : str\n        Whether or not the external noise class JITs its own functions.\n    *args\n        Additional arguments to pass to `compute_func`.\n    **kwargs\n        Additional keyword arguments to pass to `compute_func`.\n\n    Returns\n    -------\n    noise_model : NoiseWrapper\n        An instance of `NoiseWrapper` that wraps an instance of `ext_class`.\n    \"\"\"\n    shape_dtypes = ShapeDtypeStruct(dat.shape, dat.dtype)\n    data: Array | NDArray = dat\n    if not jitted:\n        data = np.array(dat)\n    inst = getattr(ext_class, compute_func)(data, *args, **kwargs)\n    return cls(inst, apply_func, jitted, shape_dtypes)\n</code></pre>"},{"location":"reference/tod/","title":"tod","text":""},{"location":"reference/tod/#jitkasi.tod.TOD","title":"<code>TOD</code>  <code>dataclass</code>","text":"<p>Class for storing time ordered data. This class is a registered pytree so it is JITable with JAX.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>Array</code> <p>The detector data for this TOD. This is a child of the pytree.</p> <code>x</code> <code>Array</code> <p>The x sky coordinates for this TOD. Nominally this should be RA in radians. Note that eventually this may become a cached property to enable on the fly pointing reconstruction for large expiriments. This is a child of the pytree.</p> <code>y</code> <code>Array</code> <p>The y sky coordinates for this TOD. Nominally this should be Dec in radians. Note that eventually this may become a cached property to enable on the fly pointing reconstruction for large expiriments. This is a child of the pytree.</p> <code>noise</code> <code>Optional[NoiseModel]</code> <p>The noise model for this TOD. Should be None when no model is initialized. This is aux data for the pytree.</p> <code>meta</code> <code>dict</code> <p>Additional metadata associated with the TOD. This is supplied only for user convenience and should not be relied on in any <code>jitkasi</code> library code. It is intended to be used in user made scripts only. This is aux data for the pytree</p> Source code in <code>jitkasi/tod.py</code> <pre><code>@register_pytree_node_class\n@dataclass\nclass TOD:\n    \"\"\"\n    Class for storing time ordered data.\n    This class is a registered pytree so it is JITable with JAX.\n\n    Attributes\n    ----------\n    data : Array\n        The detector data for this TOD.\n        This is a child of the pytree.\n    x : Array\n        The x sky coordinates for this TOD.\n        Nominally this should be RA in radians.\n        Note that eventually this may become a cached property\n        to enable on the fly pointing reconstruction for large expiriments.\n        This is a child of the pytree.\n    y : Array\n        The y sky coordinates for this TOD.\n        Nominally this should be Dec in radians.\n        Note that eventually this may become a cached property\n        to enable on the fly pointing reconstruction for large expiriments.\n        This is a child of the pytree.\n    noise : Optional[NoiseModel]\n        The noise model for this TOD.\n        Should be None when no model is initialized.\n        This is aux data for the pytree.\n    meta : dict\n        Additional metadata associated with the TOD.\n        This is supplied **only** for user convenience and\n        should **not** be relied on in any `jitkasi` library code.\n        It is intended to be used in user made scripts only.\n        This is aux data for the pytree\n    \"\"\"\n\n    data: Array\n    x: Array\n    y: Array\n    noise: n.NoiseModel = field(default_factory=n.NoiseI)\n    meta: dict = field(default_factory=dict)\n\n    def __post_init__(self):\n        # Check that all sizes are the same\n        shapes = [self.data.shape, self.x.shape, self.y.shape]\n        if not (\n            all(s[0] == shapes[0][0] for s in shapes)\n            and all(s[1] == shapes[0][1] for s in shapes)\n        ):\n            raise ValueError(\n                f\"Expected 'data', 'x', and 'y' to have the same shape but got {shapes}.\"\n            )\n\n        # Now make everything jax arrays in case we were given numpy arrays\n        self.data = jnp.array(self.data)\n        self.x = jnp.array(self.x)\n        self.y = jnp.array(self.y)\n\n    @property\n    def shape(self) -&gt; tuple[int, ...]:\n        \"\"\"\n        Get the shape of the TOD's data.\n\n        Returns\n        -------\n        shape : tuple[int, ....]\n            The shape of the TOD.\n        \"\"\"\n        return self.data.shape\n\n    @property\n    def lims(self) -&gt; Array:\n        \"\"\"\n        Get the limits of the TODs coordinates.\n\n        Returns\n        -------\n        lims : Array\n            The limits in the order:\n            (x min, x max, y min, y max).\n        \"\"\"\n        return jnp.array(\n            (jnp.min(self.x), jnp.max(self.x), jnp.min(self.y), jnp.max(self.y))\n        )\n\n    @cached_property\n    def data_filt(self) -&gt; Array:\n        \"\"\"\n        Get a copy of the data with the noise model applied.\n        This is essentially $N^{-1}d$\n\n        Returns\n        -------\n        data_filt : Array\n            The filtered data.\n            If `self.noise` is None then this is just a copy of `self.data`.\n        \"\"\"\n        if self.noise is None:\n            return jnp.copy(self.data)\n        return self.noise.apply_noise(self.data)\n\n    def copy(self, deep: bool = False) -&gt; Self:\n        \"\"\"\n        Return of copy of the TOD.\n\n        Parameters\n        ----------\n        deep : bool, default: False\n            If True do a deepcopy so that all contained\n            data is also copied. Otherwise a shallow copy is\n            made and the new TOD will reference the same arrays.\n\n        Returns\n        -------\n        copy : TOD\n            A copy of this TOD.\n        \"\"\"\n        if deep:\n            return deepcopy(self)\n        return copy(self)\n\n    def compute_noise(\n        self, noise_class: n.NoiseModel, data: Optional[Array], *args, **kwargs\n    ):\n        \"\"\"\n        Compute and set the noise model for this TOD.\n        This uses `noise_class.compute(dat=self.data...` to compute the noise.\n        Also resets the cache on `data_filt`.\n\n        Parameters\n        ----------\n        noise_class : NoiseModel\n            The class to use as the noise model.\n            Nominally a class from `jitkasi.noise`.\n        data : Optional[Array], default: None\n            Data to compute the noise model with.\n            If None we use `self.data`.\n        *args\n            Additional arguments to pass to `noise_class.compute`.\n            Note that any argunment that is a string that starts with `self` will be evaled.\n        *kwargs\n            Additional keyword arguments to pass to `noise_class.compute`.\n            Note that any argument value that is a string that starts with `self` will be evaled.\n        \"\"\"\n        args = [\n            eval(arg) if (isinstance(arg, str) and arg[:4] == \"self\") else arg\n            for arg in args\n        ]\n        kwargs = {\n            k: (eval(v) if (isinstance(v, str) and v[:4] == \"self\") else v)\n            for k, v in kwargs.items()\n        }\n        self.__dict__.pop(\"data_filt\", None)\n        if data is None:\n            data = self.data\n        self.noise = noise_class.compute(data, *args, **kwargs)\n\n    def recompute_noise(self, data: Optional[Array], *args, **kwargs):\n        \"\"\"\n        Helper function that wraps `compute_noise` but uses the same class\n        as the current instance of `self.noise`.\n\n        Parameters\n        ----------\n        data : Optional[Array], default: None\n            Data to compute the noise model with.\n            If None we use `self.data`.\n        *args\n            Additional arguments to pass to `noise_class.compute`.\n        *kwargs\n            Additional keyword arguments to pass to `noise_class.compute`.\n        \"\"\"\n        noise_class = self.noise.__class__\n        self.compute_noise(noise_class, data, *args, **kwargs)\n\n    # Functions for making this a pytree\n    # Don't call this on your own\n    def tree_flatten(self) -&gt; tuple[tuple, tuple]:\n        children = (self.data, self.x, self.y)\n        aux_data = (self.noise, self.meta)\n\n        return (children, aux_data)\n\n    @classmethod\n    def tree_unflatten(cls, aux_data, children) -&gt; Self:\n        return cls(*children, *aux_data)\n</code></pre>"},{"location":"reference/tod/#jitkasi.tod.TOD.data_filt","title":"<code>data_filt</code>  <code>cached</code> <code>property</code>","text":"<p>Get a copy of the data with the noise model applied. This is essentially \\(N^{-1}d\\)</p> <p>Returns:</p> Name Type Description <code>data_filt</code> <code>Array</code> <p>The filtered data. If <code>self.noise</code> is None then this is just a copy of <code>self.data</code>.</p>"},{"location":"reference/tod/#jitkasi.tod.TOD.lims","title":"<code>lims</code>  <code>property</code>","text":"<p>Get the limits of the TODs coordinates.</p> <p>Returns:</p> Name Type Description <code>lims</code> <code>Array</code> <p>The limits in the order: (x min, x max, y min, y max).</p>"},{"location":"reference/tod/#jitkasi.tod.TOD.shape","title":"<code>shape</code>  <code>property</code>","text":"<p>Get the shape of the TOD's data.</p> <p>Returns:</p> Name Type Description <code>shape</code> <code>tuple[int, ....]</code> <p>The shape of the TOD.</p>"},{"location":"reference/tod/#jitkasi.tod.TOD.compute_noise","title":"<code>compute_noise(noise_class, data, *args, **kwargs)</code>","text":"<p>Compute and set the noise model for this TOD. This uses <code>noise_class.compute(dat=self.data...</code> to compute the noise. Also resets the cache on <code>data_filt</code>.</p> <p>Parameters:</p> Name Type Description Default <code>noise_class</code> <code>NoiseModel</code> <p>The class to use as the noise model. Nominally a class from <code>jitkasi.noise</code>.</p> required <code>data</code> <code>Optional[Array]</code> <p>Data to compute the noise model with. If None we use <code>self.data</code>.</p> <code>None</code> <code>*args</code> <p>Additional arguments to pass to <code>noise_class.compute</code>. Note that any argunment that is a string that starts with <code>self</code> will be evaled.</p> <code>()</code> <code>*kwargs</code> <p>Additional keyword arguments to pass to <code>noise_class.compute</code>. Note that any argument value that is a string that starts with <code>self</code> will be evaled.</p> <code>{}</code> Source code in <code>jitkasi/tod.py</code> <pre><code>def compute_noise(\n    self, noise_class: n.NoiseModel, data: Optional[Array], *args, **kwargs\n):\n    \"\"\"\n    Compute and set the noise model for this TOD.\n    This uses `noise_class.compute(dat=self.data...` to compute the noise.\n    Also resets the cache on `data_filt`.\n\n    Parameters\n    ----------\n    noise_class : NoiseModel\n        The class to use as the noise model.\n        Nominally a class from `jitkasi.noise`.\n    data : Optional[Array], default: None\n        Data to compute the noise model with.\n        If None we use `self.data`.\n    *args\n        Additional arguments to pass to `noise_class.compute`.\n        Note that any argunment that is a string that starts with `self` will be evaled.\n    *kwargs\n        Additional keyword arguments to pass to `noise_class.compute`.\n        Note that any argument value that is a string that starts with `self` will be evaled.\n    \"\"\"\n    args = [\n        eval(arg) if (isinstance(arg, str) and arg[:4] == \"self\") else arg\n        for arg in args\n    ]\n    kwargs = {\n        k: (eval(v) if (isinstance(v, str) and v[:4] == \"self\") else v)\n        for k, v in kwargs.items()\n    }\n    self.__dict__.pop(\"data_filt\", None)\n    if data is None:\n        data = self.data\n    self.noise = noise_class.compute(data, *args, **kwargs)\n</code></pre>"},{"location":"reference/tod/#jitkasi.tod.TOD.copy","title":"<code>copy(deep=False)</code>","text":"<p>Return of copy of the TOD.</p> <p>Parameters:</p> Name Type Description Default <code>deep</code> <code>bool</code> <p>If True do a deepcopy so that all contained data is also copied. Otherwise a shallow copy is made and the new TOD will reference the same arrays.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>copy</code> <code>TOD</code> <p>A copy of this TOD.</p> Source code in <code>jitkasi/tod.py</code> <pre><code>def copy(self, deep: bool = False) -&gt; Self:\n    \"\"\"\n    Return of copy of the TOD.\n\n    Parameters\n    ----------\n    deep : bool, default: False\n        If True do a deepcopy so that all contained\n        data is also copied. Otherwise a shallow copy is\n        made and the new TOD will reference the same arrays.\n\n    Returns\n    -------\n    copy : TOD\n        A copy of this TOD.\n    \"\"\"\n    if deep:\n        return deepcopy(self)\n    return copy(self)\n</code></pre>"},{"location":"reference/tod/#jitkasi.tod.TOD.recompute_noise","title":"<code>recompute_noise(data, *args, **kwargs)</code>","text":"<p>Helper function that wraps <code>compute_noise</code> but uses the same class as the current instance of <code>self.noise</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Optional[Array]</code> <p>Data to compute the noise model with. If None we use <code>self.data</code>.</p> <code>None</code> <code>*args</code> <p>Additional arguments to pass to <code>noise_class.compute</code>.</p> <code>()</code> <code>*kwargs</code> <p>Additional keyword arguments to pass to <code>noise_class.compute</code>.</p> <code>{}</code> Source code in <code>jitkasi/tod.py</code> <pre><code>def recompute_noise(self, data: Optional[Array], *args, **kwargs):\n    \"\"\"\n    Helper function that wraps `compute_noise` but uses the same class\n    as the current instance of `self.noise`.\n\n    Parameters\n    ----------\n    data : Optional[Array], default: None\n        Data to compute the noise model with.\n        If None we use `self.data`.\n    *args\n        Additional arguments to pass to `noise_class.compute`.\n    *kwargs\n        Additional keyword arguments to pass to `noise_class.compute`.\n    \"\"\"\n    noise_class = self.noise.__class__\n    self.compute_noise(noise_class, data, *args, **kwargs)\n</code></pre>"},{"location":"reference/tod/#jitkasi.tod.TODVec","title":"<code>TODVec</code>  <code>dataclass</code>","text":"<p>Class to store collections of TODs. Eventually this will be responsible for handling most collective (and MPI aware) operations on TODs.</p> <p>Attributes:</p> Name Type Description <code>tods</code> <code>list[TOD]</code> <p>The TODs that belong to this TODVec. Indexing and interating the TODVec operates on this.</p> <code>comm</code> <code>Intracomm</code> <p>The MPI communicator to use.</p> Source code in <code>jitkasi/tod.py</code> <pre><code>@register_pytree_node_class\n@dataclass\nclass TODVec:\n    \"\"\"\n    Class to store collections of TODs.\n    Eventually this will be responsible for handling most\n    collective (and MPI aware) operations on TODs.\n\n    Attributes\n    ----------\n    tods : list[TOD]\n        The TODs that belong to this TODVec.\n        Indexing and interating the TODVec operates on this.\n    comm : MPI.Intracomm\n        The MPI communicator to use.\n    \"\"\"\n\n    tods: list[TOD] = field(default_factory=list)\n    comm: MPI.Intracomm = field(default_factory=MPI.COMM_WORLD.Clone)\n\n    @property\n    @jit\n    def nsamp(self) -&gt; int:\n        nsamp = 0\n        for tod in self.tods:\n            nsamp += int(jnp.product(jnp.array(tod.shape), axis=None))\n        return nsamp\n\n    @property\n    def lims(self) -&gt; Array:\n        \"\"\"\n        Get the global limits of all the TODs coordinates.\n        Will eventually be MPI aware.\n\n        Returns\n        -------\n        lims : Array\n            The limits in the order:\n            (x min, x max, y min, y max).\n        \"\"\"\n        all_lims = [tod.lims for tod in self.tods]\n        all_lims = jnp.array(all_lims).reshape(-1, 4)\n        # Order not important here, no need for tokens\n        x0, _ = mpi4jax.allreduce(jnp.min(all_lims[:, 0]), MPI.MIN, comm=self.comm)\n        x1, _ = mpi4jax.allreduce(jnp.max(all_lims[:, 1]), MPI.MAX, comm=self.comm)\n        y0, _ = mpi4jax.allreduce(jnp.min(all_lims[:, 2]), MPI.MIN, comm=self.comm)\n        y1, _ = mpi4jax.allreduce(jnp.max(all_lims[:, 3]), MPI.MAX, comm=self.comm)\n        lims = jnp.array((x0, x1, y0, y1))\n        return jnp.ravel(lims)\n\n    def copy(self, deep: bool = False, copy_comm=False) -&gt; Self:\n        \"\"\"\n        Return of copy of the TODVec.\n\n        Parameters\n        ----------\n        deep : bool, default: False\n            If True do a deepcopy so that all contained\n            TODs are also copied. Otherwise a shallow copy is\n            made and the new TODVec will reference the same TODs.\n\n        Returns\n        -------\n        copy : TODVec\n            A copy of this TODVec.\n        \"\"\"\n        comm = self.comm\n        if copy_comm:\n            comm = MPI.COMM_WORLD.Clone()\n        if deep:\n            tods = deepcopy(self.tods)\n        else:\n            tods = copy(self.tods)\n        return self.__class__(tods, comm)\n\n    # Functions to make this list like\n    def __getitem__(self, key: int) -&gt; TOD:\n        if not isinstance(key, int):\n            raise TypeError(\"TODVec is indexed by ints\")\n        return self.tods[key]\n\n    def __setitem__(self, key: int, value: TOD):\n        if not isinstance(key, int):\n            raise TypeError(\"TODVec is indexed by ints\")\n        if not isinstance(value, TOD):\n            raise TypeError(\"TODVec can only store instances of TOD\")\n\n        self.tods[key] = value\n\n    def __delitem__(self, key: int):\n        if not isinstance(key, int):\n            raise TypeError(\"TODVec is indexed by ints\")\n        del self.tods[key]\n\n    def __iter__(self) -&gt; Iterator[TOD]:\n        return self.tods.__iter__()\n\n    def __add__(self, other: Self) -&gt; Self:\n        if not isinstance(other, TODVec):\n            raise TypeError(\"Can only add other TODVecs to a TODVec\")\n        new = self.copy()\n        new += other\n        return new\n\n    def __radd__(self, other: Self) -&gt; Self:\n        if not isinstance(other, TODVec):\n            raise TypeError(\"Can only add other TODVecs to a TODVec\")\n        new = other.copy()\n        new += self\n        return new\n\n    def __iadd__(self, other: Self):\n        if not isinstance(other, TODVec):\n            raise TypeError(\"Can only add other TODVecs to a TODVec\")\n        self.tods += other.tods\n        return self\n\n    def insert(self, key: int, value: TOD):\n        if not isinstance(key, int):\n            raise TypeError(\"TODVec is indexed by ints\")\n        if not isinstance(value, TOD):\n            raise TypeError(\"TODVec can only store instances of TOD\")\n\n        self.tods.insert(key, value)\n\n    def append(self, value):\n        if not isinstance(value, TOD):\n            raise TypeError(\"TODVec can only store instances of TOD\")\n\n        self.tods.append(value)\n\n    # Functions for making this a pytree\n    # Don't call this on your own\n    def tree_flatten(self) -&gt; tuple[tuple, tuple]:\n        children = tuple(self.tods)\n        aux_data = (self.comm,)\n\n        return (children, aux_data)\n\n    @classmethod\n    def tree_unflatten(cls, aux_data, children) -&gt; Self:\n        return cls(list(children), *aux_data)\n</code></pre>"},{"location":"reference/tod/#jitkasi.tod.TODVec.lims","title":"<code>lims</code>  <code>property</code>","text":"<p>Get the global limits of all the TODs coordinates. Will eventually be MPI aware.</p> <p>Returns:</p> Name Type Description <code>lims</code> <code>Array</code> <p>The limits in the order: (x min, x max, y min, y max).</p>"},{"location":"reference/tod/#jitkasi.tod.TODVec.copy","title":"<code>copy(deep=False, copy_comm=False)</code>","text":"<p>Return of copy of the TODVec.</p> <p>Parameters:</p> Name Type Description Default <code>deep</code> <code>bool</code> <p>If True do a deepcopy so that all contained TODs are also copied. Otherwise a shallow copy is made and the new TODVec will reference the same TODs.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>copy</code> <code>TODVec</code> <p>A copy of this TODVec.</p> Source code in <code>jitkasi/tod.py</code> <pre><code>def copy(self, deep: bool = False, copy_comm=False) -&gt; Self:\n    \"\"\"\n    Return of copy of the TODVec.\n\n    Parameters\n    ----------\n    deep : bool, default: False\n        If True do a deepcopy so that all contained\n        TODs are also copied. Otherwise a shallow copy is\n        made and the new TODVec will reference the same TODs.\n\n    Returns\n    -------\n    copy : TODVec\n        A copy of this TODVec.\n    \"\"\"\n    comm = self.comm\n    if copy_comm:\n        comm = MPI.COMM_WORLD.Clone()\n    if deep:\n        tods = deepcopy(self.tods)\n    else:\n        tods = copy(self.tods)\n    return self.__class__(tods, comm)\n</code></pre>"},{"location":"reference/solutions/core/","title":"core","text":""},{"location":"reference/solutions/core/#jitkasi.solutions.core.Solution","title":"<code>Solution</code>  <code>dataclass</code>","text":"<p>Base class defining required functionality for a solution. For mapmaking all that we really need is code to project to and from TODs, additional helper functions are probably needed but anything that needs to be included in a mapmaking script explicitly should be clearly documented.</p> <p>This class is non functional but all actual solutions (maps, cuts, etc.) should subclass it and ensure that the required functions are implemented.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>An identifying string for this solution.</p> <code>data</code> <code>Array</code> <p>The model data we are solving for. For example if we are solving for a map then this is the map, if we are solving for cuts then this is the modeled offsets. Mathematically this is \\(m\\) in \\(d = Pm + n\\). This should always be a child of the pytree.</p> <code>comm</code> <code>Intracomm</code> <p>The MPI communicator to use.</p> Source code in <code>jitkasi/solutions/core.py</code> <pre><code>@register_pytree_node_class\n@dataclass\nclass Solution:\n    \"\"\"\n    Base class defining required functionality for a solution.\n    For mapmaking all that we really need is code to project to and from TODs,\n    additional helper functions are probably needed but anything that needs to\n    be included in a mapmaking script explicitly should be clearly documented.\n\n    This class is non functional but all actual solutions (maps, cuts, etc.) should\n    subclass it and ensure that the required functions are implemented.\n\n    Attributes\n    ----------\n    name : str\n        An identifying string for this solution.\n    data : Array\n        The model data we are solving for.\n        For example if we are solving for a map then this is the map,\n        if we are solving for cuts then this is the modeled offsets.\n        Mathematically this is $m$ in $d = Pm + n$.\n        This should always be a child of the pytree.\n    comm : MPI.Intracomm\n        The MPI communicator to use.\n    \"\"\"\n\n    name: str\n    data: Array\n    comm: MPI.Intracomm\n\n    @jit\n    def to_tods(self, todvec: TODVec) -&gt; TODVec:  # type: ignore\n        _ = todvec\n        pass\n\n    @jit\n    def from_tods(self, todvec: TODVec, use_filt: bool = True) -&gt; Self:  # type: ignore\n        _ = (todvec, use_filt)\n        pass\n\n    @classmethod\n    def empty(cls, **_) -&gt; Self:  # type: ignore\n        pass\n\n    def copy(self, deep: bool = False) -&gt; Self:\n        \"\"\"\n        Return of copy of the Solution.\n\n        Parameters\n        ----------\n        deep : bool, default: False\n            If True do a deepcopy so that all contained\n            data is also copied. Otherwise a mostly shallow copy is\n            made and the new Solution will reference the same objects\n            except for `data` which will be a copy.\n\n        Returns\n        -------\n        copy : Solution\n            A copy of this Solution.\n        \"\"\"\n        if deep:\n            return deepcopy(self)\n        else:\n            new = copy(self)\n            new.data = new.data.copy()\n            return new\n\n    # Math functions\n    def _self_check(self, other: Self):\n        _ = other\n        pass\n\n    def _get_to_op(self, other: Any) -&gt; Array | float:\n        if isinstance(other, type(self)):\n            to_op = other.data\n            self._self_check(other)\n        elif isinstance(other, (float, int)):\n            to_op = float(other)\n        else:\n            raise TypeError(f\"Cannot use type {type(other)} to operate on {type(self)}\")\n        return to_op\n\n    def __iadd__(self, other: Self | float) -&gt; Self:\n        to_add = self._get_to_op(other)\n        self.data = _iadd(self.data, to_add)\n        return self\n\n    def __add__(self, other: Self | float) -&gt; Self:\n        to_ret = self.copy()\n        to_ret += other\n        return to_ret\n\n    def __radd__(self, other: Self | float) -&gt; Self:\n        return self.__add__(other)\n\n    def __isub__(self, other: Any) -&gt; Self:\n        to_sub = self._get_to_op(other)\n        self.data = _isub(self.data, to_sub)\n        return self\n\n    def __sub__(self, other: Any) -&gt; Self:\n        to_ret = self.copy()\n        to_ret -= other\n        return to_ret\n\n    def __rsub__(self, other: Any) -&gt; Self:\n        return self.__sub__(other)\n\n    def __imul__(self, other: Any) -&gt; Self:\n        to_sub = self._get_to_op(other)\n        self.data = _imul(self.data, to_sub)\n        return self\n\n    def __mul__(self, other: Any) -&gt; Self:\n        to_ret = self.copy()\n        to_ret *= other\n        return to_ret\n\n    def __rmul__(self, other: Any) -&gt; Self:\n        return self.__mul__(other)\n\n    @jit\n    def __matmul__(self, other: Self) -&gt; float:\n        if not isinstance(other, type(self)):\n            raise ValueError(f\"Can't dot {type(other)} and {type(self)}\")\n        return float(jnp.sum(self.data * other.data, axis=None))\n\n    @jit\n    def reduce(self) -&gt; Self:\n        \"\"\"\n        MPI reduce the solution.\n        This adds up all the data in all insances of this solution.\n        \"\"\"\n        dat_sum, _ = mpi4jax.allreduce(self.data, op=MPI.SUM, comm=self.comm)\n        self.data = dat_sum\n        return self\n\n    # Functions for making this a pytree\n    # Don't call this on your own\n    def tree_flatten(self) -&gt; tuple[tuple, Optional[tuple]]:\n        children = (self.data,)\n        aux_data = (self.name, self.comm)\n\n        return (children, aux_data)\n\n    @classmethod\n    def tree_unflatten(cls, aux_data, children) -&gt; Self:\n        name, comm = aux_data\n        return cls(name, children[0], comm)\n</code></pre>"},{"location":"reference/solutions/core/#jitkasi.solutions.core.Solution.copy","title":"<code>copy(deep=False)</code>","text":"<p>Return of copy of the Solution.</p> <p>Parameters:</p> Name Type Description Default <code>deep</code> <code>bool</code> <p>If True do a deepcopy so that all contained data is also copied. Otherwise a mostly shallow copy is made and the new Solution will reference the same objects except for <code>data</code> which will be a copy.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>copy</code> <code>Solution</code> <p>A copy of this Solution.</p> Source code in <code>jitkasi/solutions/core.py</code> <pre><code>def copy(self, deep: bool = False) -&gt; Self:\n    \"\"\"\n    Return of copy of the Solution.\n\n    Parameters\n    ----------\n    deep : bool, default: False\n        If True do a deepcopy so that all contained\n        data is also copied. Otherwise a mostly shallow copy is\n        made and the new Solution will reference the same objects\n        except for `data` which will be a copy.\n\n    Returns\n    -------\n    copy : Solution\n        A copy of this Solution.\n    \"\"\"\n    if deep:\n        return deepcopy(self)\n    else:\n        new = copy(self)\n        new.data = new.data.copy()\n        return new\n</code></pre>"},{"location":"reference/solutions/core/#jitkasi.solutions.core.Solution.reduce","title":"<code>reduce()</code>","text":"<p>MPI reduce the solution. This adds up all the data in all insances of this solution.</p> Source code in <code>jitkasi/solutions/core.py</code> <pre><code>@jit\ndef reduce(self) -&gt; Self:\n    \"\"\"\n    MPI reduce the solution.\n    This adds up all the data in all insances of this solution.\n    \"\"\"\n    dat_sum, _ = mpi4jax.allreduce(self.data, op=MPI.SUM, comm=self.comm)\n    self.data = dat_sum\n    return self\n</code></pre>"},{"location":"reference/solutions/core/#jitkasi.solutions.core.SolutionSet","title":"<code>SolutionSet</code>  <code>dataclass</code>","text":"<p>Class to store collections of Solutions. Eventually this will be responsible for handling most collective (and MPI aware) operations on Solutions.</p> <p>Note that while this can mostly be treated like a list, '+' acts in a math like fasion adding Solutions within two SolutionSets together rather than appending them (unlike TODVec which does append).</p> <p>Attributes:</p> Name Type Description <code>solutions</code> <code>list[Solution]</code> <p>The solutions that belong to this SolutionSet. Indexing and interating the SolutionSet operates on this.</p> <code>comm</code> <code>Intracomm</code> <p>The MPI communicator to use.</p> Source code in <code>jitkasi/solutions/core.py</code> <pre><code>@register_pytree_node_class\n@dataclass\nclass SolutionSet:\n    \"\"\"\n    Class to store collections of Solutions.\n    Eventually this will be responsible for handling most\n    collective (and MPI aware) operations on Solutions.\n\n    Note that while this can mostly be treated like a list, '+' acts\n    in a math like fasion adding Solutions within two SolutionSets together\n    rather than appending them (unlike TODVec which does append).\n\n    Attributes\n    ----------\n    solutions : list[Solution]\n        The solutions that belong to this SolutionSet.\n        Indexing and interating the SolutionSet operates on this.\n    comm : MPI.Intracomm\n        The MPI communicator to use.\n    \"\"\"\n\n    solutions: list[Solution] = field(default_factory=list)\n    comm: MPI.Intracomm = field(default_factory=MPI.COMM_WORLD.Clone)\n\n    def copy(self, deep: bool = False) -&gt; Self:\n        \"\"\"\n        Return of copy of the SolutionSet.\n\n        Parameters\n        ----------\n        deep : bool, default: False\n            If True do a deepcopy so that all contained\n            Solutions are also copied. Otherwise a shallow copy is\n            made and the new SolutionSet will reference the same Solutions.\n\n        Returns\n        -------\n        copy : TODVec\n            A copy of this TODVec.\n        \"\"\"\n        if deep:\n            return deepcopy(self)\n        return copy(self)\n\n    @jit\n    def to_tods(self, todvec: TODVec) -&gt; TODVec:\n        \"\"\"\n        Project the all the Solutions into the same set of TODs.\n\n        Parameters\n        ----------\n        todvec : TODVec\n            TODVec containing TODs to project into.\n            Only used for pointing and shape information,\n            not modified in place.\n\n        Returns\n        -------\n        todvec_out : TODVec\n            A TODvec each with the Solutions projected into it.\n            The order of TODs here is the same as the input TODVec\n            and the TODs within are shallow copied to the non-data\n            Arrays reference the same memory as the original TODs.\n        \"\"\"\n        todvec_out = todvec.copy(deep=False)\n        for tod in todvec_out:\n            tod.data = jnp.zeros_like(tod.data)\n        for solution in self:\n            tmp = solution.to_tods(todvec)\n            for todout, todin in zip(todvec_out, tmp):\n                todout.data = todout.data.at[:].add(todin.data.at[:].get())\n        return todvec_out\n\n    @jit\n    def from_tods(self, todvec: TODVec, use_filt: bool = True) -&gt; Self:\n        \"\"\"\n        Project TODs into the solutions.\n\n        Parameters\n        ----------\n        todvec : TODVec\n            TODVec containing TODs to project from.\n        use_filt : bool, default: True\n            If True use data_filt instead of data.\n\n        Returns\n        -------\n        solutionset_out : SolutionSet\n            A SolutionSet with the TODs projected into each Solution.\n            The new Solutions are shallow copies of the current ones so all Arrays\n            except for data reference the same memory as before.\n        \"\"\"\n        solutionset_out = self.copy(deep=False)\n        for i, solution in enumerate(self):\n            solutionset_out[i] = solution.from_tods(todvec, use_filt)\n        return solutionset_out\n\n    # Math functions\n    def __add__(self, other: Self) -&gt; Self:\n        if len(self.solutions) != other.solutions:\n            raise ValueError(\n                \"SolutionSets can only be added if they contain the same number of solutions\"\n            )\n        summed = self.copy(deep=False)\n        for i in range(len(self.solutions)):\n            summed[i] = self[i] + other[i]\n        return summed\n\n    def __sub__(self, other: Self) -&gt; Self:\n        if len(self.solutions) != other.solutions:\n            raise ValueError(\n                \"SolutionSets can only be subtracted if they contain the same number of solutions\"\n            )\n        subbed = self.copy(deep=False)\n        for i in range(len(self.solutions)):\n            subbed[i] = self[i] - other[i]\n        return subbed\n\n    def __mul__(self, other: Self) -&gt; Self:\n        if len(self.solutions) != other.solutions:\n            raise ValueError(\n                \"SolutionSets can only be multiplied if they contain the same number of solutions\"\n            )\n        product = self.copy(deep=False)\n        for i in range(len(self.solutions)):\n            product[i] = self[i] * other[i]\n        return product\n\n    @jit\n    def __matmul__(self, other: Self) -&gt; float:\n        if len(self.solutions) != other.solutions:\n            raise ValueError(\n                \"SolutionSets can only be dotted if they contain the same number of solutions\"\n            )\n        tot = 0.0\n        for lsol, rsol in zip(self, other):\n            tot += lsol @ rsol\n        return tot\n\n    # Functions to make this list like\n    def __getitem__(self, key: int) -&gt; Solution:\n        if not isinstance(key, int):\n            raise TypeError(\"SolutionSet is indexed by ints\")\n        return self.solutions[key]\n\n    def __setitem__(self, key: int, value: Solution):\n        if not isinstance(key, int):\n            raise TypeError(\"SolutionSet is indexed by ints\")\n        if not isinstance(value, Solution):\n            raise TypeError(\"SolutionSet can only store instances of Solution\")\n\n        self.solutions[key] = value\n\n    def __delitem__(self, key: int):\n        if not isinstance(key, int):\n            raise TypeError(\"SolutionSet is indexed by ints\")\n        del self.solutions[key]\n\n    def __iter__(self) -&gt; Iterator[Solution]:\n        return self.solutions.__iter__()\n\n    def insert(self, key: int, value: Solution):\n        if not isinstance(key, int):\n            raise TypeError(\"SolutionSet is indexed by ints\")\n        if not isinstance(value, Solution):\n            raise TypeError(\"SolutionSet can only store instances of Solution\")\n\n        self.solutions.insert(key, value)\n\n    def append(self, value):\n        if not isinstance(value, Solution):\n            raise TypeError(\"SolutionSet can only store instances of Solution\")\n\n        self.solutions.append(value)\n\n    # Functions for making this a pytree\n    # Don't call this on your own\n    def tree_flatten(self) -&gt; tuple[tuple, tuple]:\n        children = tuple(self.solutions)\n        aux_data = (self.comm,)\n\n        return (children, aux_data)\n\n    @classmethod\n    def tree_unflatten(cls, aux_data, children) -&gt; Self:\n        return cls(list(children), *aux_data)\n</code></pre>"},{"location":"reference/solutions/core/#jitkasi.solutions.core.SolutionSet.copy","title":"<code>copy(deep=False)</code>","text":"<p>Return of copy of the SolutionSet.</p> <p>Parameters:</p> Name Type Description Default <code>deep</code> <code>bool</code> <p>If True do a deepcopy so that all contained Solutions are also copied. Otherwise a shallow copy is made and the new SolutionSet will reference the same Solutions.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>copy</code> <code>TODVec</code> <p>A copy of this TODVec.</p> Source code in <code>jitkasi/solutions/core.py</code> <pre><code>def copy(self, deep: bool = False) -&gt; Self:\n    \"\"\"\n    Return of copy of the SolutionSet.\n\n    Parameters\n    ----------\n    deep : bool, default: False\n        If True do a deepcopy so that all contained\n        Solutions are also copied. Otherwise a shallow copy is\n        made and the new SolutionSet will reference the same Solutions.\n\n    Returns\n    -------\n    copy : TODVec\n        A copy of this TODVec.\n    \"\"\"\n    if deep:\n        return deepcopy(self)\n    return copy(self)\n</code></pre>"},{"location":"reference/solutions/core/#jitkasi.solutions.core.SolutionSet.from_tods","title":"<code>from_tods(todvec, use_filt=True)</code>","text":"<p>Project TODs into the solutions.</p> <p>Parameters:</p> Name Type Description Default <code>todvec</code> <code>TODVec</code> <p>TODVec containing TODs to project from.</p> required <code>use_filt</code> <code>bool</code> <p>If True use data_filt instead of data.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>solutionset_out</code> <code>SolutionSet</code> <p>A SolutionSet with the TODs projected into each Solution. The new Solutions are shallow copies of the current ones so all Arrays except for data reference the same memory as before.</p> Source code in <code>jitkasi/solutions/core.py</code> <pre><code>@jit\ndef from_tods(self, todvec: TODVec, use_filt: bool = True) -&gt; Self:\n    \"\"\"\n    Project TODs into the solutions.\n\n    Parameters\n    ----------\n    todvec : TODVec\n        TODVec containing TODs to project from.\n    use_filt : bool, default: True\n        If True use data_filt instead of data.\n\n    Returns\n    -------\n    solutionset_out : SolutionSet\n        A SolutionSet with the TODs projected into each Solution.\n        The new Solutions are shallow copies of the current ones so all Arrays\n        except for data reference the same memory as before.\n    \"\"\"\n    solutionset_out = self.copy(deep=False)\n    for i, solution in enumerate(self):\n        solutionset_out[i] = solution.from_tods(todvec, use_filt)\n    return solutionset_out\n</code></pre>"},{"location":"reference/solutions/core/#jitkasi.solutions.core.SolutionSet.to_tods","title":"<code>to_tods(todvec)</code>","text":"<p>Project the all the Solutions into the same set of TODs.</p> <p>Parameters:</p> Name Type Description Default <code>todvec</code> <code>TODVec</code> <p>TODVec containing TODs to project into. Only used for pointing and shape information, not modified in place.</p> required <p>Returns:</p> Name Type Description <code>todvec_out</code> <code>TODVec</code> <p>A TODvec each with the Solutions projected into it. The order of TODs here is the same as the input TODVec and the TODs within are shallow copied to the non-data Arrays reference the same memory as the original TODs.</p> Source code in <code>jitkasi/solutions/core.py</code> <pre><code>@jit\ndef to_tods(self, todvec: TODVec) -&gt; TODVec:\n    \"\"\"\n    Project the all the Solutions into the same set of TODs.\n\n    Parameters\n    ----------\n    todvec : TODVec\n        TODVec containing TODs to project into.\n        Only used for pointing and shape information,\n        not modified in place.\n\n    Returns\n    -------\n    todvec_out : TODVec\n        A TODvec each with the Solutions projected into it.\n        The order of TODs here is the same as the input TODVec\n        and the TODs within are shallow copied to the non-data\n        Arrays reference the same memory as the original TODs.\n    \"\"\"\n    todvec_out = todvec.copy(deep=False)\n    for tod in todvec_out:\n        tod.data = jnp.zeros_like(tod.data)\n    for solution in self:\n        tmp = solution.to_tods(todvec)\n        for todout, todin in zip(todvec_out, tmp):\n            todout.data = todout.data.at[:].add(todin.data.at[:].get())\n    return todvec_out\n</code></pre>"},{"location":"reference/solutions/maps/","title":"maps","text":""},{"location":"reference/solutions/maps/#jitkasi.solutions.maps.NoiseWhite","title":"<code>NoiseWhite</code>  <code>dataclass</code>","text":"<p>A simple noise model with only white noise. Here we just weigh each pixel individually. This class is a registered pytree so it is JITable with JAX.</p> <p>Attributes:</p> Name Type Description <code>weights</code> <code>Array</code> <p>The per-pixel weights computed from the ivar map. This is a child of the pytree.</p> Source code in <code>jitkasi/solutions/maps.py</code> <pre><code>@register_pytree_node_class\n@dataclass\nclass NoiseWhite:\n    \"\"\"\n    A simple noise model with only white noise.\n    Here we just weigh each pixel individually.\n    This class is a registered pytree so it is JITable with JAX.\n\n    Attributes\n    ----------\n    weights: Array\n        The per-pixel weights computed from the ivar map.\n        This is a child of the pytree.\n    \"\"\"\n\n    weights: Array\n\n    @jit\n    def apply_noise(self, dat: Array) -&gt; Array:\n        \"\"\"\n        Apply the noise model.\n        In this case this is just rescaling each pixel by its weight.\n\n        Parameters\n        ----------\n        dat : Array\n            The data to apply the noise model to.\n            Should be 2d with `dat.shape == self.weights.shape`.\n\n        Returns\n        -------\n        dat_filt : Array\n            The data with the noise model applied.\n        \"\"\"\n        return dat * self.weights\n\n    @classmethod\n    @partial(jit, static_argnums=(0,))\n    def compute(cls, dat: Array, ivar: Array) -&gt; Self:\n        \"\"\"\n        Compute this noise model based on some input data.\n        This requires you to have a ivar map for your map.\n\n        Parameters\n        ----------\n        dat : Array\n            The map data.\n            This is only here for API compatibility.\n        ivar : Array\n            The ivar map to use as weights.\n\n        Returns\n        -------\n        noise_model : NoiseWhite\n            An instance of NoiseWhite with the computed noise model.\n        \"\"\"\n        _ = dat\n        return cls(ivar)\n\n    # Functions for making this a pytree\n    # Don't call this on your own\n    def tree_flatten(self) -&gt; tuple[tuple, None]:\n        children = (self.weights,)\n        aux_data = None\n\n        return (children, aux_data)\n\n    @classmethod\n    def tree_unflatten(cls, aux_data, children) -&gt; Self:\n        del aux_data\n        return cls(*children)\n</code></pre>"},{"location":"reference/solutions/maps/#jitkasi.solutions.maps.NoiseWhite.apply_noise","title":"<code>apply_noise(dat)</code>","text":"<p>Apply the noise model. In this case this is just rescaling each pixel by its weight.</p> <p>Parameters:</p> Name Type Description Default <code>dat</code> <code>Array</code> <p>The data to apply the noise model to. Should be 2d with <code>dat.shape == self.weights.shape</code>.</p> required <p>Returns:</p> Name Type Description <code>dat_filt</code> <code>Array</code> <p>The data with the noise model applied.</p> Source code in <code>jitkasi/solutions/maps.py</code> <pre><code>@jit\ndef apply_noise(self, dat: Array) -&gt; Array:\n    \"\"\"\n    Apply the noise model.\n    In this case this is just rescaling each pixel by its weight.\n\n    Parameters\n    ----------\n    dat : Array\n        The data to apply the noise model to.\n        Should be 2d with `dat.shape == self.weights.shape`.\n\n    Returns\n    -------\n    dat_filt : Array\n        The data with the noise model applied.\n    \"\"\"\n    return dat * self.weights\n</code></pre>"},{"location":"reference/solutions/maps/#jitkasi.solutions.maps.NoiseWhite.compute","title":"<code>compute(dat, ivar)</code>  <code>classmethod</code>","text":"<p>Compute this noise model based on some input data. This requires you to have a ivar map for your map.</p> <p>Parameters:</p> Name Type Description Default <code>dat</code> <code>Array</code> <p>The map data. This is only here for API compatibility.</p> required <code>ivar</code> <code>Array</code> <p>The ivar map to use as weights.</p> required <p>Returns:</p> Name Type Description <code>noise_model</code> <code>NoiseWhite</code> <p>An instance of NoiseWhite with the computed noise model.</p> Source code in <code>jitkasi/solutions/maps.py</code> <pre><code>@classmethod\n@partial(jit, static_argnums=(0,))\ndef compute(cls, dat: Array, ivar: Array) -&gt; Self:\n    \"\"\"\n    Compute this noise model based on some input data.\n    This requires you to have a ivar map for your map.\n\n    Parameters\n    ----------\n    dat : Array\n        The map data.\n        This is only here for API compatibility.\n    ivar : Array\n        The ivar map to use as weights.\n\n    Returns\n    -------\n    noise_model : NoiseWhite\n        An instance of NoiseWhite with the computed noise model.\n    \"\"\"\n    _ = dat\n    return cls(ivar)\n</code></pre>"},{"location":"reference/solutions/maps/#jitkasi.solutions.maps.WCSMap","title":"<code>WCSMap</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Solution</code></p> <p>Class for solving for a map. Uses a WCS header for its pixel definitions. See <code>Solution</code> for inherited attributes. This class is a registered pytree so it is JITable with JAX.</p> <p>TODO: Caching and purging of pixelization</p> <p>Attributes:</p> Name Type Description <code>wcs</code> <code>WCS</code> <p>The WCS header that defines the map pixelization. This is aux data for the pytree.</p> <code>pixelization</code> <code>str</code> <p>The pixelization method used when projecting to/from TODs. Currently accepted values are: * 'nn': Nearest neighpor pixelization. This is aux data for the pytree.</p> <code>noise</code> <code>NoiseModel, default: NoiseI</code> <p>The map space noise model.</p> <code>ivar</code> <code>(Array, ones(1))</code> <p>The inverse variance of the map. By default this is one everywhere.</p> Source code in <code>jitkasi/solutions/maps.py</code> <pre><code>@register_pytree_node_class\n@dataclass\nclass WCSMap(Solution):\n    \"\"\"\n    Class for solving for a map.\n    Uses a WCS header for its pixel definitions.\n    See `Solution` for inherited attributes.\n    This class is a registered pytree so it is JITable with JAX.\n\n    TODO: Caching and purging of pixelization\n\n    Attributes\n    ----------\n    wcs : WCS\n        The WCS header that defines the map pixelization.\n        This is aux data for the pytree.\n    pixelization : str\n        The pixelization method used when projecting to/from TODs.\n        Currently accepted values are:\n        * 'nn': Nearest neighpor pixelization.\n        This is aux data for the pytree.\n    noise : NoiseModel, default: NoiseI\n        The map space noise model.\n    ivar : Array, jnp.ones(1)\n        The inverse variance of the map.\n        By default this is one everywhere.\n    \"\"\"\n\n    wcs: WCS\n    pixelization: str\n    noise: NoiseModel = field(default_factory=NoiseI)\n    ivar: Array = field(default_factory=partial(jnp.ones, 1))\n    _pix_reg: dict = field(init=False, repr=False, default_factory=dict)\n\n    def __post_init__(self):\n        # Add pixelization methods to the registry\n        self._pix_reg[\"nn\"] = self.nn_pix\n        # Check that we have a valid pixelization scheme\n        if self.pixelization not in self._pix_reg.keys():\n            raise ValueError(f\"Invalid pixelization: {self.pixelization}\")\n        if self.ivar.shape != self.data.shape:\n            self.ivar = jnp.ones_like(self.data)\n\n    @cached_property\n    def xy(self) -&gt; tuple[Array, Array]:\n        \"\"\"\n        Get the ra and dex at each pixel in the map.\n\n        Returns\n        -------\n        ra : Array\n            The Ra at each pixel.\n        dec : Array\n            The dec at eahc pixel\n        \"\"\"\n        xx, yy = np.meshgrid(\n            np.arange(1, self.data.shape[0] + 1, dtype=float),\n            np.arange(1, self.data.shape[1] + 1, dtype=float),\n        )\n        x, y = self.wcs.wcs_pix2world(np.array(xx.ravel()), np.array(yy.ravel()), 1)\n        return (\n            jnp.array(x).reshape(self.data.shape) * jnp.pi / 180.0,\n            jnp.array(y).reshape(self.data.shape) * jnp.pi / 180.0,\n        )\n\n    @jit\n    def nn_pix(self, tod: TOD) -&gt; Array:\n        coords = jnp.column_stack(\n            [jnp.ravel(tod.x * 180.0 / jnp.pi), jnp.ravel(tod.y * 180.0 / jnp.pi)]\n        )\n        # -1 is to go between unit offset in FITS and zero offset in python\n        pix = jnp.round(jnp.array(self.wcs.wcs_world2pix(coords, 1)) - 1.0).reshape(\n            (2,) + tod.data.shape\n        )\n        return pix.astype(jnp.int32)\n\n    @jit\n    def _nn_bin(self, bin_into: Array, data: Array, pix: Array):\n        bin_into = bin_into.at[pix].add(data.at[:].get(), mode=\"drop\")\n        return bin_into\n\n    @jit\n    def _nn_unbin(self, unbin_into: Array, data: Array, pix: Array):\n        unbin_into = unbin_into.at[:].add(data.at[pix].get(mode=\"fill\", fill_value=0.0))\n        return unbin_into\n\n    @jit\n    def to_tods(self, todvec: TODVec) -&gt; TODVec:\n        \"\"\"\n        Project the map into TODs.\n\n        Parameters\n        ----------\n        todvec : TODVec\n            TODVec containing TODs to project into.\n            Only used for pointing and shape information,\n            not modified in place.\n\n        Returns\n        -------\n        todvec_out : TODVec\n            A TODvec where each with the map projected into it.\n            The order of TODs here is the same as the input TODVec\n            and the TODs within are shallow copied to the non-data\n            Arrays reference the same memory as the original TODs.\n        \"\"\"\n        todvec_out = todvec.copy(deep=False)\n        for tod in todvec_out:\n            pix = self._pix_reg[self.pixelization](tod)\n            tod.data = jnp.zeros_like(tod.data)\n            if self.pixelization == \"nn\":\n                tod.data = self._nn_unbin(tod.data, self.data, pix)\n        return todvec_out\n\n    @jit\n    def from_tods(self, todvec: TODVec, use_filt: bool = True) -&gt; Self:\n        \"\"\"\n        Project TODs into a map.\n\n        Parameters\n        ----------\n        todvec : TODVec\n            TODVec containing TODs to project from.\n        use_filt : bool, defauls: True\n            If True use data_filt instead of data.\n\n        Returns\n        -------\n        wcsmap_out : WCSMap\n            A WCSmap with the TODs binned into it.\n            This is a shallow copy of the current object so all Arrays\n            except for data reference the same memory as this object.\n        \"\"\"\n        wcsmap_out = self.copy(deep=False)\n        wcsmap_out.data = jnp.zeros_like(self.data)\n        for tod in todvec:\n            pix = self._pix_reg[self.pixelization](tod)\n            data = tod.data\n            if use_filt:\n                data = tod.data_filt\n            if self.pixelization == \"nn\":\n                wcsmap_out.data = self._nn_bin(wcsmap_out.data, data, pix)\n        return wcsmap_out\n\n    @jit\n    def make_hits(self, todvec: TODVec, use_filt: bool = True) -&gt; Self:\n        \"\"\"\n        Get the hits map given a set of TODs.\n\n        Parameters\n        ----------\n        todvec : TODVec\n            TODVec containing TODs to project from.\n        use_filt : bool, defauls: True\n            If True apply the TOD noise model.\n\n        Returns\n        -------\n        wcsmap : WCSMap\n            A WCSmap with the hits map included as `wcsmap.ivar`.\n            This is the same as the current object,\n            but needs to be returned for jit to work.\n        \"\"\"\n        self.ivar = jnp.zeros_like(self.data)\n        for tod in todvec:\n            pix = self._pix_reg[self.pixelization](tod)\n            data = jnp.ones_like(tod.data)\n            if use_filt:\n                data = tod.noise.apply_noise(data)\n            if self.pixelization == \"nn\":\n                self.ivar = self._nn_bin(self.ivar, data, pix)\n        return self\n\n    @cached_property\n    def data_filt(self) -&gt; Array:\n        \"\"\"\n        Get a copy of the data with the noise model applied.\n        This is essentially $M^{-1}m$\n\n        Returns\n        -------\n        data_filt : Array\n            The filtered data.\n            If `self.noise` is None then this is just a copy of `self.data`.\n        \"\"\"\n        if self.noise is None:\n            return jnp.copy(self.data)\n        return self.noise.apply_noise(self.data)\n\n    def compute_noise(\n        self, noise_class: Type[NoiseModel], data: Optional[Array], *args, **kwargs\n    ):\n        \"\"\"\n        Compute and set the noise model for this map.\n        This uses `noise_class.compute(dat=self.data...` to compute the noise.\n        Also resets the cache on `data_filt`.\n\n        Parameters\n        ----------\n        noise_class : Type[NoiseModel]\n            The class to use as the noise model.\n            Nominally a class from `jitkasi.noise`.\n        data : Optional[Array], default: None\n            Data to compute the noise model with.\n            If None we use `self.data`.\n        *args\n            Additional arguments to pass to `noise_class.compute`.\n            Note that any argunment that is a string that starts with `self` will be evaled.\n        *kwargs\n            Additional keyword .reshape(self.data.shape)arguments to pass to `noise_class.compute`.\n            Note that any argument value that is a string that starts with `self` will be evaled.\n        \"\"\"\n        args = [\n            eval(arg) if (isinstance(arg, str) and arg[:4] == \"self\") else arg\n            for arg in args\n        ]\n        kwargs = {\n            k: (eval(v) if (isinstance(v, str) and v[:4] == \"self\") else v)\n            for k, v in kwargs.items()\n        }\n        self.__dict__.pop(\"data_filt\", None)\n        if data is None:\n            data = self.data\n        self.noise = noise_class.compute(data, *args, **kwargs)\n\n    def recompute_noise(self, data: Optional[Array], *args, **kwargs):\n        \"\"\"\n        Helper function that wraps `compute_noise` but uses the same class\n        as the current instance of `self.noise`.\n\n        Parameters\n        ----------\n        data : Optional[Array], default: None\n            Data to compute the noise model with.\n            If None we use `self.data`.\n        *args\n            Additional arguments to pass to `noise_class.compute`.\n        *kwargs\n            Additional keyword arguments to pass to `noise_class.compute`.\n        \"\"\"\n        noise_class = self.noise.__class__\n        self.compute_noise(noise_class, data, *args, **kwargs)\n\n    @jit\n    def reduce(self) -&gt; Self:\n        \"\"\"\n        MPI reduce the solution.\n        This adds up all the data in all insances of this solution.\n        \"\"\"\n        self.data, token = mpi4jax.allreduce(self.data, op=MPI.SUM, comm=self.comm)\n        self.ivar, _ = mpi4jax.allreduce(\n            self.ivar, op=MPI.SUM, comm=self.comm, token=token\n        )\n        return self\n\n    @classmethod\n    def empty(\n        cls,\n        *,\n        name: str,\n        comm: MPI.Intracomm,\n        wcs: WCS,\n        lims: tuple[float, float, float, float],\n        pad=0,\n        square=False,\n        pixelization=\"nn\",\n        **_,\n    ) -&gt; Self:\n        \"\"\"\n        Initialize an empty map.\n\n        Parameters\n        ----------\n        name : str\n            The name of the map.\n        comm : MPI.Intracomm\n            The MPI communicator to use.\n        wcs : WCS\n            The WCS kernel to use for this map.\n        lims : tuple[float, float, float, float]\n            The limits of the map in radians.\n            Should be (RA low, RA high, Dec low, Dec high).\n        pad : int, default: 0\n            Number of pixels to pad the map by.\n        square : bool, default: False\n            If True make the map square.\n        pixelization : str, default: 'nn'\n            The pixelization method to use.\n            See `WCSMap` documentation for more details.\n        \"\"\"\n        corners = np.zeros([4, 2])\n        corners[0, :] = [lims[0], lims[2]]\n        corners[1, :] = [lims[0], lims[3]]\n        corners[2, :] = [lims[1], lims[2]]\n        corners[3, :] = [lims[1], lims[3]]\n\n        pix_corners = np.array(wcs.wcs_world2pix(corners * 180 / jnp.pi, 1))\n        pix_corners = np.round(pix_corners)\n\n        if pix_corners.min() &lt; -0.5:\n            print(\n                \"corners seem to have gone negative in SkyMap projection.  not good, you may want to check this.\"\n            )\n        nx = int(pix_corners[:, 0].max() + pad)\n        ny = int(pix_corners[:, 1].max() + pad)\n\n        if square:\n            if nx &gt; ny:\n                ny = nx\n            else:\n                nx = ny\n        data = jnp.zeros((nx, ny))\n\n        return cls(name, data, comm, wcs, pixelization)\n\n    def _self_check(self, other: Self):\n        if self.wcs != other.wcs:\n            raise ValueError(\"Cannot operate on WCSMaps that have different WCSs\")\n\n    # Functions for making this a pytree\n    # Don't call this on your own\n    def tree_flatten(self) -&gt; tuple[tuple, tuple]:\n        children = (self.data, self.ivar, self.noise)\n        aux_data = (self.name, self.comm, self.wcs, self.pixelization)\n\n        return (children, aux_data)\n\n    @classmethod\n    def tree_unflatten(cls, aux_data, children) -&gt; Self:\n        name, comm, wcs, pixelization = aux_data\n        data, ivar, noise = children\n        return cls(name, data, comm, wcs, pixelization, noise, ivar)\n</code></pre>"},{"location":"reference/solutions/maps/#jitkasi.solutions.maps.WCSMap.data_filt","title":"<code>data_filt</code>  <code>cached</code> <code>property</code>","text":"<p>Get a copy of the data with the noise model applied. This is essentially \\(M^{-1}m\\)</p> <p>Returns:</p> Name Type Description <code>data_filt</code> <code>Array</code> <p>The filtered data. If <code>self.noise</code> is None then this is just a copy of <code>self.data</code>.</p>"},{"location":"reference/solutions/maps/#jitkasi.solutions.maps.WCSMap.xy","title":"<code>xy</code>  <code>cached</code> <code>property</code>","text":"<p>Get the ra and dex at each pixel in the map.</p> <p>Returns:</p> Name Type Description <code>ra</code> <code>Array</code> <p>The Ra at each pixel.</p> <code>dec</code> <code>Array</code> <p>The dec at eahc pixel</p>"},{"location":"reference/solutions/maps/#jitkasi.solutions.maps.WCSMap.compute_noise","title":"<code>compute_noise(noise_class, data, *args, **kwargs)</code>","text":"<p>Compute and set the noise model for this map. This uses <code>noise_class.compute(dat=self.data...</code> to compute the noise. Also resets the cache on <code>data_filt</code>.</p> <p>Parameters:</p> Name Type Description Default <code>noise_class</code> <code>Type[NoiseModel]</code> <p>The class to use as the noise model. Nominally a class from <code>jitkasi.noise</code>.</p> required <code>data</code> <code>Optional[Array]</code> <p>Data to compute the noise model with. If None we use <code>self.data</code>.</p> <code>None</code> <code>*args</code> <p>Additional arguments to pass to <code>noise_class.compute</code>. Note that any argunment that is a string that starts with <code>self</code> will be evaled.</p> <code>()</code> <code>*kwargs</code> <p>Additional keyword .reshape(self.data.shape)arguments to pass to <code>noise_class.compute</code>. Note that any argument value that is a string that starts with <code>self</code> will be evaled.</p> <code>{}</code> Source code in <code>jitkasi/solutions/maps.py</code> <pre><code>def compute_noise(\n    self, noise_class: Type[NoiseModel], data: Optional[Array], *args, **kwargs\n):\n    \"\"\"\n    Compute and set the noise model for this map.\n    This uses `noise_class.compute(dat=self.data...` to compute the noise.\n    Also resets the cache on `data_filt`.\n\n    Parameters\n    ----------\n    noise_class : Type[NoiseModel]\n        The class to use as the noise model.\n        Nominally a class from `jitkasi.noise`.\n    data : Optional[Array], default: None\n        Data to compute the noise model with.\n        If None we use `self.data`.\n    *args\n        Additional arguments to pass to `noise_class.compute`.\n        Note that any argunment that is a string that starts with `self` will be evaled.\n    *kwargs\n        Additional keyword .reshape(self.data.shape)arguments to pass to `noise_class.compute`.\n        Note that any argument value that is a string that starts with `self` will be evaled.\n    \"\"\"\n    args = [\n        eval(arg) if (isinstance(arg, str) and arg[:4] == \"self\") else arg\n        for arg in args\n    ]\n    kwargs = {\n        k: (eval(v) if (isinstance(v, str) and v[:4] == \"self\") else v)\n        for k, v in kwargs.items()\n    }\n    self.__dict__.pop(\"data_filt\", None)\n    if data is None:\n        data = self.data\n    self.noise = noise_class.compute(data, *args, **kwargs)\n</code></pre>"},{"location":"reference/solutions/maps/#jitkasi.solutions.maps.WCSMap.empty","title":"<code>empty(*, name, comm, wcs, lims, pad=0, square=False, pixelization='nn', **_)</code>  <code>classmethod</code>","text":"<p>Initialize an empty map.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the map.</p> required <code>comm</code> <code>Intracomm</code> <p>The MPI communicator to use.</p> required <code>wcs</code> <code>WCS</code> <p>The WCS kernel to use for this map.</p> required <code>lims</code> <code>tuple[float, float, float, float]</code> <p>The limits of the map in radians. Should be (RA low, RA high, Dec low, Dec high).</p> required <code>pad</code> <code>int</code> <p>Number of pixels to pad the map by.</p> <code>0</code> <code>square</code> <code>bool</code> <p>If True make the map square.</p> <code>False</code> <code>pixelization</code> <code>str</code> <p>The pixelization method to use. See <code>WCSMap</code> documentation for more details.</p> <code>'nn'</code> Source code in <code>jitkasi/solutions/maps.py</code> <pre><code>@classmethod\ndef empty(\n    cls,\n    *,\n    name: str,\n    comm: MPI.Intracomm,\n    wcs: WCS,\n    lims: tuple[float, float, float, float],\n    pad=0,\n    square=False,\n    pixelization=\"nn\",\n    **_,\n) -&gt; Self:\n    \"\"\"\n    Initialize an empty map.\n\n    Parameters\n    ----------\n    name : str\n        The name of the map.\n    comm : MPI.Intracomm\n        The MPI communicator to use.\n    wcs : WCS\n        The WCS kernel to use for this map.\n    lims : tuple[float, float, float, float]\n        The limits of the map in radians.\n        Should be (RA low, RA high, Dec low, Dec high).\n    pad : int, default: 0\n        Number of pixels to pad the map by.\n    square : bool, default: False\n        If True make the map square.\n    pixelization : str, default: 'nn'\n        The pixelization method to use.\n        See `WCSMap` documentation for more details.\n    \"\"\"\n    corners = np.zeros([4, 2])\n    corners[0, :] = [lims[0], lims[2]]\n    corners[1, :] = [lims[0], lims[3]]\n    corners[2, :] = [lims[1], lims[2]]\n    corners[3, :] = [lims[1], lims[3]]\n\n    pix_corners = np.array(wcs.wcs_world2pix(corners * 180 / jnp.pi, 1))\n    pix_corners = np.round(pix_corners)\n\n    if pix_corners.min() &lt; -0.5:\n        print(\n            \"corners seem to have gone negative in SkyMap projection.  not good, you may want to check this.\"\n        )\n    nx = int(pix_corners[:, 0].max() + pad)\n    ny = int(pix_corners[:, 1].max() + pad)\n\n    if square:\n        if nx &gt; ny:\n            ny = nx\n        else:\n            nx = ny\n    data = jnp.zeros((nx, ny))\n\n    return cls(name, data, comm, wcs, pixelization)\n</code></pre>"},{"location":"reference/solutions/maps/#jitkasi.solutions.maps.WCSMap.from_tods","title":"<code>from_tods(todvec, use_filt=True)</code>","text":"<p>Project TODs into a map.</p> <p>Parameters:</p> Name Type Description Default <code>todvec</code> <code>TODVec</code> <p>TODVec containing TODs to project from.</p> required <code>use_filt</code> <code>bool, defauls: True</code> <p>If True use data_filt instead of data.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>wcsmap_out</code> <code>WCSMap</code> <p>A WCSmap with the TODs binned into it. This is a shallow copy of the current object so all Arrays except for data reference the same memory as this object.</p> Source code in <code>jitkasi/solutions/maps.py</code> <pre><code>@jit\ndef from_tods(self, todvec: TODVec, use_filt: bool = True) -&gt; Self:\n    \"\"\"\n    Project TODs into a map.\n\n    Parameters\n    ----------\n    todvec : TODVec\n        TODVec containing TODs to project from.\n    use_filt : bool, defauls: True\n        If True use data_filt instead of data.\n\n    Returns\n    -------\n    wcsmap_out : WCSMap\n        A WCSmap with the TODs binned into it.\n        This is a shallow copy of the current object so all Arrays\n        except for data reference the same memory as this object.\n    \"\"\"\n    wcsmap_out = self.copy(deep=False)\n    wcsmap_out.data = jnp.zeros_like(self.data)\n    for tod in todvec:\n        pix = self._pix_reg[self.pixelization](tod)\n        data = tod.data\n        if use_filt:\n            data = tod.data_filt\n        if self.pixelization == \"nn\":\n            wcsmap_out.data = self._nn_bin(wcsmap_out.data, data, pix)\n    return wcsmap_out\n</code></pre>"},{"location":"reference/solutions/maps/#jitkasi.solutions.maps.WCSMap.make_hits","title":"<code>make_hits(todvec, use_filt=True)</code>","text":"<p>Get the hits map given a set of TODs.</p> <p>Parameters:</p> Name Type Description Default <code>todvec</code> <code>TODVec</code> <p>TODVec containing TODs to project from.</p> required <code>use_filt</code> <code>bool, defauls: True</code> <p>If True apply the TOD noise model.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>wcsmap</code> <code>WCSMap</code> <p>A WCSmap with the hits map included as <code>wcsmap.ivar</code>. This is the same as the current object, but needs to be returned for jit to work.</p> Source code in <code>jitkasi/solutions/maps.py</code> <pre><code>@jit\ndef make_hits(self, todvec: TODVec, use_filt: bool = True) -&gt; Self:\n    \"\"\"\n    Get the hits map given a set of TODs.\n\n    Parameters\n    ----------\n    todvec : TODVec\n        TODVec containing TODs to project from.\n    use_filt : bool, defauls: True\n        If True apply the TOD noise model.\n\n    Returns\n    -------\n    wcsmap : WCSMap\n        A WCSmap with the hits map included as `wcsmap.ivar`.\n        This is the same as the current object,\n        but needs to be returned for jit to work.\n    \"\"\"\n    self.ivar = jnp.zeros_like(self.data)\n    for tod in todvec:\n        pix = self._pix_reg[self.pixelization](tod)\n        data = jnp.ones_like(tod.data)\n        if use_filt:\n            data = tod.noise.apply_noise(data)\n        if self.pixelization == \"nn\":\n            self.ivar = self._nn_bin(self.ivar, data, pix)\n    return self\n</code></pre>"},{"location":"reference/solutions/maps/#jitkasi.solutions.maps.WCSMap.recompute_noise","title":"<code>recompute_noise(data, *args, **kwargs)</code>","text":"<p>Helper function that wraps <code>compute_noise</code> but uses the same class as the current instance of <code>self.noise</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Optional[Array]</code> <p>Data to compute the noise model with. If None we use <code>self.data</code>.</p> <code>None</code> <code>*args</code> <p>Additional arguments to pass to <code>noise_class.compute</code>.</p> <code>()</code> <code>*kwargs</code> <p>Additional keyword arguments to pass to <code>noise_class.compute</code>.</p> <code>{}</code> Source code in <code>jitkasi/solutions/maps.py</code> <pre><code>def recompute_noise(self, data: Optional[Array], *args, **kwargs):\n    \"\"\"\n    Helper function that wraps `compute_noise` but uses the same class\n    as the current instance of `self.noise`.\n\n    Parameters\n    ----------\n    data : Optional[Array], default: None\n        Data to compute the noise model with.\n        If None we use `self.data`.\n    *args\n        Additional arguments to pass to `noise_class.compute`.\n    *kwargs\n        Additional keyword arguments to pass to `noise_class.compute`.\n    \"\"\"\n    noise_class = self.noise.__class__\n    self.compute_noise(noise_class, data, *args, **kwargs)\n</code></pre>"},{"location":"reference/solutions/maps/#jitkasi.solutions.maps.WCSMap.reduce","title":"<code>reduce()</code>","text":"<p>MPI reduce the solution. This adds up all the data in all insances of this solution.</p> Source code in <code>jitkasi/solutions/maps.py</code> <pre><code>@jit\ndef reduce(self) -&gt; Self:\n    \"\"\"\n    MPI reduce the solution.\n    This adds up all the data in all insances of this solution.\n    \"\"\"\n    self.data, token = mpi4jax.allreduce(self.data, op=MPI.SUM, comm=self.comm)\n    self.ivar, _ = mpi4jax.allreduce(\n        self.ivar, op=MPI.SUM, comm=self.comm, token=token\n    )\n    return self\n</code></pre>"},{"location":"reference/solutions/maps/#jitkasi.solutions.maps.WCSMap.to_tods","title":"<code>to_tods(todvec)</code>","text":"<p>Project the map into TODs.</p> <p>Parameters:</p> Name Type Description Default <code>todvec</code> <code>TODVec</code> <p>TODVec containing TODs to project into. Only used for pointing and shape information, not modified in place.</p> required <p>Returns:</p> Name Type Description <code>todvec_out</code> <code>TODVec</code> <p>A TODvec where each with the map projected into it. The order of TODs here is the same as the input TODVec and the TODs within are shallow copied to the non-data Arrays reference the same memory as the original TODs.</p> Source code in <code>jitkasi/solutions/maps.py</code> <pre><code>@jit\ndef to_tods(self, todvec: TODVec) -&gt; TODVec:\n    \"\"\"\n    Project the map into TODs.\n\n    Parameters\n    ----------\n    todvec : TODVec\n        TODVec containing TODs to project into.\n        Only used for pointing and shape information,\n        not modified in place.\n\n    Returns\n    -------\n    todvec_out : TODVec\n        A TODvec where each with the map projected into it.\n        The order of TODs here is the same as the input TODVec\n        and the TODs within are shallow copied to the non-data\n        Arrays reference the same memory as the original TODs.\n    \"\"\"\n    todvec_out = todvec.copy(deep=False)\n    for tod in todvec_out:\n        pix = self._pix_reg[self.pixelization](tod)\n        tod.data = jnp.zeros_like(tod.data)\n        if self.pixelization == \"nn\":\n            tod.data = self._nn_unbin(tod.data, self.data, pix)\n    return todvec_out\n</code></pre>"}]}